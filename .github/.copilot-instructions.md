# EMC Auditor Plugin - AI Assistant Development Guide

**Repository**: KiCAD_Custom_DRC  
**Plugin**: emc_auditor_plugin.py  
**Purpose**: EMC/DRC verification for KiCad PCB designs

---

## ‚ö†Ô∏è LICENSING RESTRICTIONS

**License**: Non-Commercial Proprietary License (NC)  
**CRITICAL**: This project is under a non-commercial, proprietary license.

**AI Assistant Rules**:
- ‚ùå **DO NOT** suggest adding third-party libraries that would force a license change to GPL
- ‚ùå **DO NOT** recommend copyleft dependencies (GPL, LGPL, AGPL)
- ‚úÖ **DO** use permissive licenses only (MIT, BSD, Apache 2.0)
- ‚úÖ **DO** use Python standard library whenever possible
- ‚úÖ **DO** implement custom code rather than GPL dependencies

**Code Modifications**: All code changes require explicit author approval.  
**Commercial Use**: Prohibited without written permission from copyright holder.

---

## üîí SENSITIVE DATA PROTECTION

**CRITICAL**: Never commit sensitive or personally identifiable information to git repository.

**Prohibited in Commits and Files**:
- ‚ùå **Personal Information**: Real names, usernames, email addresses, phone numbers
- ‚ùå **Corporate Identifiers**: Company names, internal project names, organization details
- ‚ùå **File Paths**: Absolute paths containing usernames or company names (e.g., `C:\Users\JohnDoe\...`)
- ‚ùå **Network Information**: Internal URLs, IP addresses, server names, VPN endpoints
- ‚ùå **Credentials**: Passwords, API keys, tokens, certificates, SSH keys
- ‚ùå **Internal Documentation**: Screenshots with sensitive UI, proprietary diagrams, confidential reports

**Required Practices**:
- ‚úÖ **Use Placeholders**: Replace specific paths with `<repository_path>`, `<kicad_plugins_path>`, `<user_home>`
- ‚úÖ **Use Environment Variables**: `$env:USERPROFILE`, `$HOME`, `%APPDATA%` instead of hardcoded paths
- ‚úÖ **Generic Examples**: Use example.com, user@example.com, generic company names in documentation
- ‚úÖ **Template Files**: Provide `.template` files for user-specific configurations (e.g., `sync_to_kicad.ps1.template`)
- ‚úÖ **Gitignore Local Configs**: Add user-specific files to `.gitignore` (e.g., `sync_to_kicad.ps1`, `*.local.ps1`)

**Commit Message Rules**:
- ‚ùå **Never mention** what sensitive data was removed (e.g., "Removed company name XYZ")
- ‚úÖ **Use generic descriptions**: "Update paths to use environment variables", "Use generic placeholders"

**Before Committing - Always Review**:
1. Run `git diff --cached` to review all changes
2. Search for company/personal identifiers: `git grep -i "company_name"`
3. Check file paths for usernames: Look for patterns like `Users\[name]\` or `/home/[name]/`
4. Verify commit messages don't reference sensitive data removal

---

## Quick Context for AI Assistants

This plugin checks electromagnetic compatibility (EMC) rules on KiCad PCB designs. All violations are visualized using a **standardized marker pattern** on the User.Comments layer.

### Current Implementation Status

**‚úÖ Implemented Rules:**
1. **Via Stitching** - Ensures GND return vias near high-speed signal vias
2. **Decoupling Capacitors** - Verifies caps near IC power pins (smart net matching)
3. **Ground Plane Continuity** - Checks continuous ground under/around high-speed traces

**üöß Configuration Ready (Implementation Pending):**
- Clearance/Creepage (IEC60664-1/IPC2221)
- Trace Width (current capacity)
- Differential Pairs (length matching)
- High-Speed Signals (stub length, bend radius)
- EMI Filtering (ferrite bead placement)

---

## CRITICAL RULE: Violation Marker Pattern

**ALL DRC checks MUST follow this exact pattern:**

### 1. Create Individual Violation Group
```python
violation_group = pcbnew.PCB_GROUP(board)
violation_group.SetName(f"EMC_{RuleCategory}_{ItemID}_{violations+1}")
board.Add(violation_group)
```

**Group Naming Examples:**
- `EMC_Decap_U1_VCC` - Decoupling check on IC U1, VCC net
- `EMC_Via_15` - Via stitching violation #15
- `EMC_GndPlane_CLK_3` - Ground plane check on CLK net, violation #3

**Why:** Allows users to select/delete individual violations via "Select Items in Group"

### 2. Draw Error Marker (Circle + Text)
```python
self.draw_error_marker(
    board,
    violation_position,     # pcbnew.VECTOR2I
    "VIOLATION MESSAGE",    # Can include {distance:.1f} placeholder
    marker_layer,
    violation_group
)
```

**Result:** Red circle (0.8mm radius) + text label at violation location

### 3. Draw Arrow to Related Component (OPTIONAL)
```python
if config.get('draw_arrow_to_target', True):
    self.draw_arrow(
        board,
        start_position,      # Where violation is
        target_position,     # Related component location
        "‚Üí TARGET_REF",      # Arrow label (e.g., "‚Üí C15")
        marker_layer,
        violation_group
    )
```

**Result:** Arrow with 0.5mm arrowhead pointing from violation to related item

---

## Configuration File Integration

**File**: `emc_rules.toml`  
**Format**: TOML (parsed with tomllib/tomli/toml)

**Minimum Required Parameters:**
```toml
[your_rule]
enabled = true                    # REQUIRED: Enable/disable check
description = "What it checks"    # REQUIRED: Documentation
violation_message = "TEXT HERE"   # REQUIRED: What to display

# Rule-specific logic parameters (customize as needed)
max_distance_mm = 2.0
net_classes = ["HighSpeed", "Clock"]
net_patterns = ["VCC", "GND"]

# Optional visual enhancements
draw_arrow_to_target = true
show_target_label = true
```

---

## Template for New DRC Rule

```python
def check_your_rule(self, board, marker_layer, config):
    """
    Template for new DRC rule implementation
    
    Args:
        board: pcbnew.BOARD object
        marker_layer: Layer ID for User.Comments
        config: dict from emc_rules.toml [your_rule] section
    
    Returns:
        int: Number of violations found
    """
    # Parse config parameters
    max_dist = pcbnew.FromMM(config.get('max_distance_mm', 2.0))
    net_classes = config.get('critical_net_classes', ['HighSpeed'])
    violation_msg = config.get('violation_message', 'VIOLATION FOUND')
    draw_arrow = config.get('draw_arrow_to_target', True)
    
    violations = 0
    
    # Get items to check
    items_to_check = self.get_items_for_check(board, net_classes)
    
    if not items_to_check:
        print(f"WARNING: No items found for [your_rule]. Skipping.")
        return 0
    
    # Check each item
    for item in items_to_check:
        if self.detect_violation(item):
            # Step 1: Create group
            violation_group = pcbnew.PCB_GROUP(board)
            violation_group.SetName(f"EMC_YourRule_{item.GetNetname()}_{violations+1}")
            board.Add(violation_group)
            
            # Step 2: Draw circle + text
            violation_pos = item.GetPosition()
            self.draw_error_marker(
                board, 
                violation_pos, 
                violation_msg, 
                marker_layer, 
                violation_group
            )
            
            # Step 3 (optional): Draw arrow
            if draw_arrow:
                target_pos = self.find_related_component(item)
                if target_pos:
                    self.draw_arrow(
                        board,
                        violation_pos,
                        target_pos,
                        f"‚Üí {item.GetReference()}",
                        marker_layer,
                        violation_group
                    )
            
            violations += 1
    
    return violations
```

---

## Existing Helper Functions (DO NOT REIMPLEMENT)

```python
# Distance calculation (2D Euclidean)
distance = self.get_distance(point1, point2)  # Returns internal units

# Draw violation markers
self.draw_error_marker(board, pos, message, layer, group)
self.draw_arrow(board, start_pos, end_pos, label, layer, group)

# Clear old markers before run
self.clear_previous_markers(board)

# Unit conversions
internal_units = pcbnew.FromMM(mm_value)
mm_value = pcbnew.ToMM(internal_units)

# CRITICAL: Net Class detection (reuse this function)
net_list = self.get_nets_by_class(board, 'HIGH_VOLTAGE_DC')
# Returns list of net names matching Net Class (substring match)
```

---

## CRITICAL: KiCad Net Class Detection

**ALWAYS use the centralized `get_nets_by_class()` function** for finding nets assigned to Net Classes.

### Why Substring Matching is Required

KiCad Net Classes can be:
1. **Single class**: `net.GetNetClassName()` returns `"HighSpeed"`
2. **Multiple classes**: Returns `"HighSpeed,Default"` (comma-separated)
3. **Wildcard assignment**: User assigns nets using patterns like `"*In*"` in Board Setup

**Example from CSI Analyzer project**:
- User created Net Class `"HIGH_VOLTAGE_DC"` in KiCad
- Assigned nets using wildcard pattern `"*In*"` in Board Setup ‚Üí Net Classes
- Nets like `"Net-(U5-In)"`, `"Net-(U7-In)"` get this class
- `GetNetClassName()` returns `"HIGH_VOLTAGE_DC,Default"` (multi-class)

### Correct API Pattern

```python
# ‚úÖ CORRECT: Use centralized helper (handles substring matching)
net_list = self.get_nets_by_class(board, 'HIGH_VOLTAGE_DC')
for net_name in net_list:
    print(f"Found net: {net_name}")

# ‚ùå WRONG: Exact match fails with comma-separated classes
for net in board.GetNetInfo().NetsByName().values():
    if net.GetNetClassName() == 'HIGH_VOLTAGE_DC':  # Misses "HIGH_VOLTAGE_DC,Default"
        ...

# ‚ùå WRONG: Using non-existent Find() method
net_classes = board.GetNetClasses()
net_class = net_classes.Find('HIGH_VOLTAGE_DC')  # AttributeError: no Find() method
```

### Function Signature

```python
def get_nets_by_class(self, board, class_name):
    """
    Get all nets belonging to a specific Net Class (substring match).
    
    Args:
        board: pcbnew.BOARD object
        class_name: Net Class name to search for (e.g., 'HIGH_VOLTAGE_DC')
    
    Returns:
        list: Net names (strings) that belong to this class
    
    Example:
        >>> nets = self.get_nets_by_class(board, 'HIGH_VOLTAGE_DC')
        >>> print(nets)  # ['Net-(U5-In)', 'Net-(U7-In)', 'Net-(U8-In)']
    """
```

### Real-World Use Cases

**Via Stitching** - Find critical signal vias:
```python
critical_classes = ['HighSpeed', 'Clock']
for class_name in critical_classes:
    nets = self.get_nets_by_class(board, class_name)
    for net_name in nets:
        # Check vias on this net
```

**Clearance/Creepage** - Assign voltage domains:
```python
voltage_domains = [
    {'name': 'HIGH_VOLTAGE_DC', 'voltage': 400},
    {'name': 'MAINS_L', 'voltage': 230}
]
for domain in voltage_domains:
    nets = self.get_nets_by_class(board, domain['name'])
    if nets:
        print(f"Domain {domain['name']}: {len(nets)} net(s) assigned")
```

**Decoupling Capacitors** - Find power nets:
```python
power_classes = ['Power', 'VCC', '3V3']
for class_name in power_classes:
    nets = self.get_nets_by_class(board, class_name)
    # Check if capacitors are nearby
```

---

## Registration in Run() Method

**ALWAYS register your check in the Run() method:**

```python
def Run(self):
    board = pcbnew.GetBoard()
    self.clear_previous_markers(board)
    
    general = self.config.get('general', {})
    marker_layer = board.GetLayerID(general.get('marker_layer', 'Cmts.User'))
    
    violations_found = 0
    
    # Existing checks...
    via_cfg = self.config.get('via_stitching', {})
    if via_cfg.get('enabled', True):
        violations_found += self.check_via_stitching(board, marker_layer, via_cfg)
    
    # YOUR NEW CHECK HERE:
    your_rule_cfg = self.config.get('your_rule', {})
    if your_rule_cfg.get('enabled', False):  # Default: disabled for new rules
        violations_found += self.check_your_rule(board, marker_layer, your_rule_cfg)
    
    pcbnew.Refresh()
    print(f"EMC Audit Complete. Found {violations_found} violation(s).")
```

---

## Visual Consistency Requirements

**All markers MUST use these dimensions:**
- Circle radius: `0.8mm` (from config `marker_circle_radius_mm`)
- Line width: `0.1mm` (from config `marker_line_width_mm`)
- Text size: `0.5mm` (from config `marker_text_size_mm`)
- Text offset: `1.2mm` (from config `marker_text_offset_mm`)
- Arrow head: `0.5mm` length (hardcoded in `draw_arrow()`)

**Layer**: Always `User.Comments` (Cmts.User)

**Colors**: KiCad manages layer colors - plugin draws shapes only

---

## Error Handling Pattern

```python
try:
    # Your checking logic
    if not required_data:
        print(f"WARNING: Missing data for [your_rule]. Skipping check.")
        return 0
    
    # Perform checks...
    
except Exception as e:
    print(f"ERROR in [your_rule] check: {e}")
    import traceback
    traceback.print_exc()
    return 0
```

---

## Testing Checklist

Before committing new DRC rule:

- [ ] Rule has `enabled = true/false` toggle in config
- [ ] Violation markers visible on User.Comments layer
- [ ] Each violation has unique group name starting with "EMC_"
- [ ] Right-click marker ‚Üí "Select Items in Group" selects all markers
- [ ] Re-running plugin clears old markers
- [ ] Console prints "Found X violation(s)"
- [ ] README.md updated with usage example and visualization
- [ ] Config file includes properly documented template

---

## Common Pitfalls to Avoid

‚ùå **WRONG:** Creating one group for all violations
```python
# Don't do this:
violation_group = pcbnew.PCB_GROUP(board)
board.Add(violation_group)
for item in items:
    self.draw_error_marker(...)  # All in same group
```

‚úÖ **CORRECT:** Create individual group per violation
```python
# Do this:
for item in items:
    violation_group = pcbnew.PCB_GROUP(board)  # New group per violation
    board.Add(violation_group)
    self.draw_error_marker(...)
```

‚ùå **WRONG:** Hardcoding marker dimensions
```python
radius = 800000  # Don't hardcode internal units
```

‚úÖ **CORRECT:** Use config values
```python
radius = pcbnew.FromMM(self.config['general']['marker_circle_radius_mm'])
```

‚ùå **WRONG:** Missing group name prefix
```python
violation_group.SetName(f"Violation_{n}")  # Won't be cleaned up properly
```

‚úÖ **CORRECT:** Use "EMC_" prefix
```python
violation_group.SetName(f"EMC_YourRule_{n}")  # Cleaned by clear_previous_markers()
```

---

## Performance Guidelines

- **Avoid O(n¬≥)** - Keep checks O(n¬≤) or better
- **Cache layer lookups** - Call `board.GetLayerID()` once
- **Spatial indexing** - Group items by layer before distance checks
- **Conditional arrows** - Only draw if `draw_arrow = true` in config
- **Early returns** - Exit if no items to check

---

## Files to Modify When Adding New Rule

1. **emc_auditor_plugin.py**
   - Add `check_your_rule()` method
   - Register in `Run()` method
   - Update `get_default_config()` if needed

2. **emc_rules.toml**
   - Add `[your_rule]` section with parameters
   - Document all config options with comments

3. **README.md**
   - Add usage example to "Usage" section
   - Update "Implemented Rules" or "Planned Rules" table
   - Add visualization example if pattern differs

4. **YOUR_RULE.md** (optional)
   - Create detailed documentation if rule is complex
   - Include implementation rationale and EMC theory

---

## Priority Order for Future Implementation

Based on `emc_rules.toml` configuration:

1. **Trace Width** - Power trace current capacity (IPC-2221)
2. **Clearance/Creepage** - High-voltage safety (IEC60664-1)
3. **Differential Pairs** - Length matching, impedance control
4. **High-Speed Signals** - Stub length, bend radius, via count
5. **EMI Filtering** - Ferrite bead/filter placement on interfaces

All use the **same marker visualization pattern**.

---

## Development and Deployment Workflow

**CRITICAL**: After making changes to plugin files, you MUST deploy them to KiCad's plugins directory.

### Files that Require Deployment

When you modify any of these files:
- `emc_auditor_plugin.py` - Main plugin code
- `clearance_creepage.py` - Clearance/creepage checker module
- `emc_rules.toml` - Configuration file
- `emc_icon.png` - Toolbar icon

### Deployment Script

**Always run this after making changes:**

```powershell
cd "<repository_path>"
.\sync_to_kicad.ps1
```

**What it does:**
- Copies updated files to KiCad plugins directory:
  ```
  <kicad_plugins_path>
  ```
- Reports file sizes and sync status
- Shows ‚úÖ/‚ùå for each file copied

**After sync:**
- Restart KiCad to reload the plugin
- Test changes in KiCad PCB Editor

### Complete Development Cycle

```powershell
# 1. Make code changes in repository
code emc_auditor_plugin.py

# 2. Deploy to KiCad
.\sync_to_kicad.ps1

# 3. Test in KiCad
# - Open KiCad PCB Editor
# - Click EMC Auditor toolbar button
# - Verify violations display correctly

# 4. If issues found, edit and repeat
code emc_auditor_plugin.py
.\sync_to_kicad.ps1
# (restart KiCad and test again)

# 5. Commit when working correctly
git add emc_auditor_plugin.py clearance_creepage.py emc_rules.toml
git commit -m "feat: implement Phase 1 clearance checking"
git push
```

### Important Notes

- **sync_to_kicad.ps1 is gitignored** - Contains local machine paths
- Template available: `sync_to_kicad.ps1.template`
- If you see "file not found" errors, check the `$PluginsDir` variable in the script
- The deployed files in KiCad plugins directory are NOT tracked by Git

---

## Questions or Issues?

- **Plugin Architecture**: See `EMCAuditorPlugin` class in `emc_auditor_plugin.py`
- **Marker Drawing**: See `draw_error_marker()` and `draw_arrow()` methods
- **Config Parsing**: See `load_config()` and `get_default_config()` methods
- **Examples**: Study `check_via_stitching()`, `check_decoupling()`, `check_ground_plane()`

**License**: MIT License  
**KiCad Version**: 9.0.7+  
**Python Version**: 3.8+ (requires tomli/toml for Python < 3.11)
