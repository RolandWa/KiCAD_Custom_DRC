# EMC Auditor Plugin - AI Assistant Development Guide

**Repository**: KiCAD_Custom_DRC  
**Plugin**: emc_auditor_plugin.py  
**Version**: 1.3.0  
**Last Updated**: February 12, 2026  
**Purpose**: EMC/DRC verification for KiCad PCB designs

---

## Quick Context for AI Assistants

This plugin checks electromagnetic compatibility (EMC) rules on KiCad PCB designs using a **modular architecture** with dependency injection. All violations are visualized using a **standardized marker pattern** on the User.Comments layer.

**Current Modules (v1.3.0 - Refactored February 12, 2026):**
- `emc_auditor_plugin.py` - Main orchestrator with centralized utilities (899 lines)
- `via_stitching.py` - Via stitching verification for EMI reduction (221 lines)
- `decoupling.py` - Decoupling capacitor proximity verification for signal integrity (188 lines)
- `emi_filtering.py` - EMI filtering verification on interface connectors (697 lines)
- `clearance_creepage.py` - Electrical clearance/creepage verification (639 lines)
- `ground_plane.py` - Ground plane continuity verification for high-speed signals (495 lines)

**Recent Refactoring (February 12, 2026):**
- âœ… Eliminated ~170 lines of duplicate code across all modules
- âœ… Centralized logging utility (`create_logger`) - no more duplicate `log()` methods
- âœ… Centralized violation group creation (`create_violation_group`) - standardized naming
- âœ… Extended dependency injection to pass logger and group creator functions

---

## ğŸ—ï¸ Modular Architecture Pattern

### Overview

The plugin uses a **modular architecture** where complex DRC checks are separated into dedicated modules while reusing **centralized utility functions** from the main plugin. This eliminates code duplication and ensures consistency.

**Key Principle**: Main plugin owns:
- **Centralized utilities**: Logger creation, violation group creation
- **Visualization functions**: Draw markers, arrows
- **Geometry functions**: Distance calculation
- **Board utilities**: Net class lookup

Modules receive these utilities via **dependency injection** - no code duplication.

### Example: clearance_creepage.py Module (Current Pattern)

```python
# File: clearance_creepage.py
from clearance_creepage import ClearanceCreepageChecker

class ClearanceCreepageChecker:
    def __init__(self, board, marker_layer, config, report_lines, verbose=True, auditor=None):
        """
        Initialize checker with board context and configuration.
        
        Args:
            auditor: Reference to EMCAuditorPlugin instance (for utility functions)
        """
        self.board = board
        self.marker_layer = marker_layer
        self.config = config
        self.report_lines = report_lines  # Shared report log
        self.verbose = verbose
        self.auditor = auditor  # Access to plugin's utility functions
        
        # Utility functions (injected during check() call)
        self.log = None  # Logger function (centralized)
        self.create_group = None  # Group creator function (centralized)
        self.draw_marker = None
        self.draw_arrow = None
        self.get_distance = None
        
        # Results tracking
        self.violation_count = 0
    
    def check(self, draw_marker_func, draw_arrow_func, get_distance_func, log_func, create_group_func):
        """
        Main entry point - receives injected utility functions.
        
        Args:
            draw_marker_func: Function(board, pos, msg, layer, group)
            draw_arrow_func: Function(board, start, end, label, layer, group)
            get_distance_func: Function(pos1, pos2) returns distance
            log_func: Function(msg, force=False) for logging (centralized)
            create_group_func: Function(board, check_type, identifier, number) creates PCB_GROUP
        
        Returns:
            int: Number of violations found
        """
        # Store injected utility functions
        self.log = log_func  # Centralized logger from main plugin
        self.create_group = create_group_func  # Centralized group creator
        self.draw_marker = draw_marker_func
        self.draw_arrow = draw_arrow_func
        self.get_distance = get_distance_func
        
        self.log("\n=== CLEARANCE & CREEPAGE CHECK START ===", force=True)
        
        # Use injected function from auditor
        nets_in_class = self.auditor.get_nets_by_class(self.board, "HIGH_VOLTAGE")
        
        # When violation found:
        if violation_detected:
            # Use centralized group creator (no manual boilerplate)
            violation_group = self.create_group(
                self.board,
                "Clearance",  # Check type
                f"{net_a}_{net_b}",  # Identifier
                self.violation_count + 1  # Sequence number
            )
            
            self.draw_marker(self.board, pos, "CLEARANCE TOO SMALL", self.marker_layer, violation_group)
            self.violation_count += 1
        
        self.log(f"\n=== CLEARANCE CHECK COMPLETE: {self.violation_count} violation(s) ===", force=True)
        return self.violation_count
```

### Main Plugin Integration

```python
# File: emc_auditor_plugin.py
from clearance_creepage import ClearanceCreepageChecker

class EMCAuditorPlugin(pcbnew.ActionPlugin):
    
    # ===== REUSABLE UTILITY FUNCTIONS =====
    
    def get_distance(self, p1, p2):
        """Calculate 2D Euclidean distance between two points"""
        return math.sqrt((p1.x - p2.x)**2 + (p1.y - p2.y)**2)
    
    def get_nets_by_class(self, board, class_name):
        """
        Get all nets belonging to a Net Class (substring match).
        
        Handles:
        - Single class: "HighSpeed"
        - Multiple classes: "HighSpeed,Default" (comma-separated)
        - Wildcards: User patterns like "*In*" in Board Setup
        
        Returns:
            list: Net names (strings) in this class
        """
        matching_nets = []
        all_nets = board.GetNetInfo().NetsByName().values()
        
        for net in all_nets:
            net_class = net.GetNetClassName()
            net_name = net.GetNetname()
            
            # Substring match (handles comma-separated classes)
            if class_name in net_class and net_name:
                matching_nets.append(net_name)
        
        return matching_nets
    
    def draw_error_marker(self, board, pos, message, layer, marker_group):
        """Draw circle + text marker at violation location"""
        general = self.config.get('general', {})
        radius = pcbnew.FromMM(general.get('marker_circle_radius_mm', 0.8))
        # ... (implementation details)
    
    def draw_arrow(self, board, start_pos, end_pos, label, layer, marker_group):
        """Draw arrow from start to end with optional label"""
        # ... (implementation details)
    
    # ===== CENTRALIZED UTILITIES (v1.3.0 - February 12, 2026) =====
    
    def create_logger(self, verbose, report_lines):
        """
        Create a logging function for modules (eliminates code duplication).
        
        Returns a closure that conditionally logs to console and report_lines.
        This eliminates the need for each module to implement its own log() method.
        
        Args:
            verbose: bool - Enable detailed logging
            report_lines: list - Shared report lines (modified in-place)
        
        Returns:
            function: log(msg, force=False) callable
        """
        def log(msg, force=False):
            if verbose or force:
                print(msg)
                if verbose:
                    report_lines.append(msg)
        return log
    
    def create_violation_group(self, board, check_type, identifier, violation_number=None):
        """
        Create a standardized violation group (eliminates boilerplate).
        
        Creates PCB_GROUP with consistent naming: EMC_{CheckType}_{Identifier}_{Number}
        This eliminates the 3-line boilerplate repeated 40+ times across modules.
        
        Args:
            board: pcbnew.BOARD object
            check_type: str - Type of check (Via, Decap, GndPlane, EMI, Clearance)
            identifier: str - Unique identifier (net name, component ref, etc.)
            violation_number: int - Optional sequence number
        
        Returns:
            pcbnew.PCB_GROUP: Created group ready for use
        """
        group = pcbnew.PCB_GROUP(board)
        
        if violation_number is not None:
            name = f"EMC_{check_type}_{identifier}_{violation_number}"
        else:
            name = f"EMC_{check_type}_{identifier}"
        
        group.SetName(name)
        board.Add(group)
        return group
    
    # ===== MODULE INTEGRATION =====
    
    def check_clearance_creepage(self, board, marker_layer, config):
        """Delegate to ClearanceCreepageChecker module"""
        
        # Create checker instance
        verbose = self.config.get('general', {}).get('verbose_logging', True)
        checker = ClearanceCreepageChecker(
            board=board,
            marker_layer=marker_layer,
            config=config,
            report_lines=self.report_lines,  # Shared report
            verbose=verbose,
            auditor=self  # Pass self for utility access
        )
        
        # Create centralized utility functions
        log_func = self.create_logger(verbose, self.report_lines)
        create_group_func = lambda board, check_type, ident, num=None: self.create_violation_group(board, check_type, ident, num)
        
        # Inject all utility functions (dependency injection pattern)
        violations = checker.check(
            draw_marker_func=self.draw_error_marker,
            draw_arrow_func=self.draw_arrow,
            get_distance_func=self.get_distance,
            log_func=log_func,  # Centralized logger
            create_group_func=create_group_func  # Centralized group creator
        )
        
        return violations
```

### Example 2: via_stitching.py Module

The via stitching module follows the same pattern, checking that critical signal vias have nearby ground return vias for EMI reduction.

```python
# File: via_stitching.py
from via_stitching import ViaStitchingChecker

class ViaStitchingChecker:
    def __init__(self, board, marker_layer, config, report_lines, verbose=True, auditor=None):
        """Initialize via stitching checker with board context"""
        self.board = board
        self.marker_layer = marker_layer
        self.config = config
        self.report_lines = report_lines
        self.verbose = verbose
        self.auditor = auditor  # Access to plugin utilities
        
        # Injected utility functions (set during check() call)
        self.log = None  # Centralized logger
        self.create_group = None  # Centralized group creator
        self.draw_marker = None
        self.draw_arrow = None
        self.get_distance = None
        
        self.violation_count = 0
    
    def check(self, draw_marker_func, draw_arrow_func, get_distance_func, log_func, create_group_func):
        """Main entry point - receives injected utility functions"""
        # Store for reuse
        self.log = log_func
        self.create_group = create_group_func
        self.draw_marker = draw_marker_func
        self.draw_arrow = draw_arrow_func
        self.get_distance = get_distance_func
        
        self.log("\n=== VIA STITCHING CHECK START ===", force=True)
        
        # Get critical nets via Net Classes (preferred method)
        critical_classes = self.config.get('critical_net_classes', ['HighSpeed'])
        for crit_class in critical_classes:
            nets_in_class = self.auditor.get_nets_by_class(self.board, crit_class)
            # Check vias on these nets...
        
        # When violation found:
        if violation_detected:
            # Use centralized utilities (no duplication)
            violation_group = self.create_group(self.board, "Via", net_name, self.violation_count + 1)
            self.draw_marker(self.board, via_pos, "NO GND VIA", self.marker_layer, violation_group)
            self.violation_count += 1
        
        return self.violation_count
```

**Main Plugin Integration:**
```python
# File: emc_auditor_plugin.py
from via_stitching import ViaStitchingChecker

def check_via_stitching(self, board, marker_layer, config):
    """Delegate to ViaStitchingChecker module"""
    
    if ViaStitchingChecker is None:
        print("âš ï¸  Via stitching checker module not available")
        return 0
    
    verbose = self.config.get('general', {}).get('verbose_logging', True)
    checker = ViaStitchingChecker(
        board=board,
        marker_layer=marker_layer,
        config=config,
        report_lines=self.report_lines,
        verbose=verbose,
        auditor=self
    )
    
    # Create and inject centralized utilities
    log_func = self.create_logger(verbose, self.report_lines)
    create_group_func = self.create_violation_group
    
    violations = checker.check(
        draw_marker_func=self.draw_error_marker,
        draw_arrow_func=self.draw_arrow,
        get_distance_func=self.get_distance,
        log_func=log_func,
        create_group_func=create_group_func
    )
    
    return violations
```

**Configuration (emc_rules.toml):**
```toml
[via_stitching]
enabled = true
max_distance_mm = 2.0
critical_net_classes = ["HighSpeed", "Clock"]
ground_net_patterns = ["GND", "GROUND", "VSS"]
violation_message = "NO GND VIA"
draw_arrow_to_nearest_gnd = true
```

### Example 3: decoupling.py Module

The decoupling capacitor module checks that ICs have nearby decoupling capacitors on power pins for signal integrity.

```python
# File: decoupling.py
from decoupling import DecouplingChecker

class DecouplingChecker:
    def __init__(self, board, marker_layer, config, report_lines, verbose=True, auditor=None):
        """Initialize decoupling capacitor checker with board context"""
        self.board = board
        self.marker_layer = marker_layer
        self.config = config
        self.report_lines = report_lines
        self.verbose = verbose
        self.auditor = auditor  # Access to plugin utilities
        
        # Injected utility functions
        self.log = None
        self.create_group = None
        self.draw_marker = None
        self.draw_arrow = None
        self.get_distance = None
    
    def check(self, draw_marker_func, draw_arrow_func, get_distance_func, log_func, create_group_func):
        """Main entry point - receives injected utility functions"""
        # Store for reuse
        self.log = log_func
        self.create_group = create_group_func
        self.draw_marker = draw_marker_func
        self.draw_arrow = draw_arrow_func
        self.get_distance = get_distance_func
        
        self.log("\n=== DECOUPLING CAPACITOR CHECK START ===", force=True)
        
        # Get IC power pins and check for nearby capacitors
        ic_prefixes = self.config.get('ic_reference_prefixes', ['U'])
        cap_prefixes = self.config.get('capacitor_reference_prefixes', ['C'])
        
        # Scan for ICs and check power pin decoupling...
        return violation_count
```

**Main Plugin Integration:**
```python
# File: emc_auditor_plugin.py
from decoupling import DecouplingChecker

def check_decoupling(self, board, marker_layer, config):
    """Delegate to DecouplingChecker module"""
    
    if DecouplingChecker is None:
        print("âš ï¸  Decoupling checker module not available")
        return 0
    
    verbose = self.config.get('general', {}).get('verbose_logging', True)
    checker = DecouplingChecker(
        board=board,
        marker_layer=marker_layer,
        config=config,
        report_lines=self.report_lines,
        verbose=verbose,
        auditor=self
    )
    
    # Inject centralized utilities
    log_func = self.create_logger(verbose, self.report_lines)
    
    violations = checker.check(
        draw_marker_func=self.draw_error_marker,
        draw_arrow_func=self.draw_arrow,
        get_distance_func=self.get_distance,
        log_func=log_func,
        create_group_func=self.create_violation_group
    )
    
    return violations
```

**Configuration (emc_rules.toml):**
```toml
[decoupling]
enabled = true
max_distance_mm = 3.0
ic_reference_prefixes = ["U"]
capacitor_reference_prefixes = ["C"]
power_net_patterns = ["VCC", "VDD", "3V3", "5V"]
violation_message = "CAP TOO FAR ({distance:.1f}mm)"
draw_arrow_to_nearest_cap = true
show_capacitor_label = true
```

**Example 4: EMI Filtering Module** (`emi_filtering.py`)

Complex module (697 lines) for EMI filtering verification on interface connectors. Detects filter topologies (Pi, T, LC, RC), differential pair filters, and common-mode chokes.

**Module Interface:**
```python
class EMIFilteringChecker:
    def __init__(self, board, marker_layer, config, report_lines, verbose, auditor):
        """Initialize with dependency injection pattern."""
        self.board = board
        self.marker_layer = marker_layer
        self.config = config.get('emi_filtering', {})
        self.report_lines = report_lines
        self.verbose = verbose
        self.auditor = auditor
        
        # Injected utilities (set during check() call)
        self.log = None
        self.create_group = None
        self.draw_marker = None
        self.draw_arrow = None
        self.get_distance = None
    
    def check(self, draw_marker_func, draw_arrow_func, get_distance_func, log_func, create_group_func):
        """Check EMI filtering on interface connectors.
        
        Returns: int - Number of violations found
        """
        # Store injected utilities
        self.log = log_func
        self.create_group = create_group_func
        self.draw_marker = draw_marker_func
        self.draw_arrow = draw_arrow_func
        self.get_distance = get_distance_func
        
        # Scans connectors (default prefix 'J')
        # Detects interface types (USB, Ethernet, HDMI, CAN, RS485, RS232)
        # Checks each signal pad for EMI filtering
        # Detects differential pairs and common-mode filters
        # Classifies topology: Pi, T, LC, RC, L, C, R, simple
        # Creates violation markers using self.create_group()
        ...
```

**Main Plugin Delegation:**
```python
def check_emi_filtering(self, board, marker_layer, config):
    """Check EMI filtering (delegates to module)."""
    if EMIFilteringChecker is None:
        print("âš ï¸  EMI filtering checker module not available")
        return 0
    
    verbose = self.config.get('general', {}).get('verbose_logging', True)
    checker = EMIFilteringChecker(
        board=board,
        marker_layer=marker_layer,
        config=config,
        report_lines=self.report_lines,
        verbose=verbose,
        auditor=self
    )
    
    # Inject centralized utilities
    log_func = self.create_logger(verbose, self.report_lines)
    
    return checker.check(
        draw_marker_func=self.draw_error_marker,
        draw_arrow_func=self.draw_arrow,
        get_distance_func=self.get_distance,
        log_func=log_func,
        create_group_func=self.create_violation_group
    )
```

**Configuration ([emi_filtering] in emc_rules.toml):**
```toml
[emi_filtering]
enabled = true
connector_prefix = "J"
filter_component_prefixes = ["R", "L", "FB", "C", "D"]
max_filter_distance_mm = 10.0
min_filter_type = "LC"
violation_message = "NO EMI FILTER"

# Component class mappings for topology detection
component_classes.inductor_prefixes = ["L", "FB"]
component_classes.capacitor_prefixes = ["C"]
component_classes.resistor_prefixes = ["R"]

# Differential pair detection patterns
differential_pairs.patterns = [
    ["_P", "_N"], ["_p", "_n"], ["+", "-"],
    ["DP", "DM"], ["dp", "dm"],
    ["TXP", "TXN"], ["txp", "txn"],
    ["RXP", "RXN"], ["rxp", "rxn"],
    ["CANH", "CANL"]
]
differential_pairs.min_common_mode_choke_pins = 4

# Ground and power net patterns (for series/shunt analysis)
ground_patterns = ["GND", "GROUND", "VSS", "AGND", "DGND", "PGND"]
power_patterns = ["VCC", "VDD", "PWR", "+", "VBUS", "3V3", "5V"]
```

**Module Features:**
- **Interface Detection**: Identifies USB, Ethernet, HDMI, CAN, RS485, RS232 from reference/footprint names
- **Topology Classification**: Detects Pi (C-L-C), T (L-C-L), LC, RC, L, C, R, simple filters
- **Series/Shunt Analysis**: Determines if component is in-line (series) or to GND/power (shunt)
- **Differential Pair Detection**: Finds common-mode chokes (4+ pin inductors/FBs on both nets)
- **Common-Mode Capacitors**: Detects capacitors with pads on both differential nets
- **Filter Hierarchy**: Pi > T > LC > RC > L > C > R > simple
- **Differential Bonus**: "Differential + RC" treated as equivalent to single-ended "LC"
- **Per-Pad Markers**: Creates individual violation groups for each signal pad

### Benefits of This Architecture (v1.3.0+)

âœ… **No Code Duplication** - Centralized utilities eliminate duplicate code  
âœ… **Single Source of Truth** - Logger and group creator defined once in main plugin  
âœ… **180+ Lines Saved** - Eliminated ~170 lines of duplicate code across 5 modules  
âœ… **Consistent Behavior** - All modules use identical logging and group naming  
âœ… **Easy Maintenance** - Update logger format in one place, affects all modules  
âœ… **Clean Separation** - Complex checks isolated in modules  
âœ… **Shared Logging** - All modules append to same `report_lines` list  
âœ… **Consistent Visualization** - All use same `draw_error_marker()` style  
âœ… **Testability** - Modules can be unit tested with mocked functions  

**Code Quality Improvements (February 12, 2026):**
- âŒ **Before**: Each module implemented its own `log()` method (6 lines x 5 modules = 30 lines)
- âœ… **After**: Single `create_logger()` in main plugin (30 lines total)
- âŒ **Before**: Each module created violation groups manually (3 lines x 40+ instances = 120+ lines)
- âœ… **After**: Single `create_violation_group()` in main plugin (36 lines total)

**Net Result**: ~170 lines eliminated, ~66 lines added = **~104 line reduction** with better maintainability.

### When to Create a Module

**Create separate module if:**
- Check logic exceeds 200 lines
- Requires specialized data structures or algorithms
- Implements external standard (IEC, IPC, ISO)
- Reusable across multiple checks

**Keep in main plugin if:**
- Check logic < 100 lines
- Simple comparison/measurement
- No specialized domain knowledge

### Centralized Utility Functions in Main Plugin (v1.3.0)

**1. create_logger(verbose, report_lines) - Logger Factory**

Returns a closure function for logging. Modules no longer implement their own `log()` methods.

```python
def create_logger(self, verbose, report_lines):
    """Create logging function for modules (eliminates code duplication)"""
    def log(msg, force=False):
        if verbose or force:
            print(msg)
            if verbose:
                report_lines.append(msg)
    return log
```

**Used in module:**
```python
def check(self, ..., log_func, ...):
    self.log = log_func  # Store injected logger
    
    # Use throughout module
    self.log("Processing...")  # Verbose only
    self.log("âœ… Complete", force=True)  # Always visible
```

**2. create_violation_group(board, check_type, identifier, violation_number) - Group Factory**

Creates standardized PCB_GROUP with consistent naming. Modules no longer write boilerplate.

```python
def create_violation_group(self, board, check_type, identifier, violation_number=None):
    """Create standardized violation group (eliminates boilerplate)"""
    group = pcbnew.PCB_GROUP(board)
    
    if violation_number is not None:
        name = f"EMC_{check_type}_{identifier}_{violation_number}"
    else:
        name = f"EMC_{check_type}_{identifier}"
    
    group.SetName(name)
    board.Add(group)
    return group
```

**Used in module:**
```python
def check(self, ..., create_group_func, ...):
    self.create_group = create_group_func  # Store injected creator
    
    # When violation found (one line instead of three)
    violation_group = self.create_group(
        self.board,
        "Via",  # Check type
        net_name,  # Identifier
        self.violation_count + 1  # Sequence number
    )
    
    self.draw_marker(self.board, pos, msg, layer, violation_group)
```

**3. Geometry Functions (Injected)**

```python
def get_distance(self, p1, p2):
    """Calculate 2D Euclidean distance between two points"""
    return math.sqrt((p1.x - p2.x)**2 + (p1.y - p2.y)**2)
```

**4. Visualization Functions (Injected)**

```python
def draw_error_marker(self, board, pos, message, layer, marker_group)
def draw_arrow(self, board, start, end, label, layer, marker_group)
```

**5. Board Utilities (Access via auditor)**

```python
def get_nets_by_class(self, board, class_name):
    """Get all nets belonging to a Net Class (substring match)"""
    # Implementation in main plugin
    # Modules access via self.auditor.get_nets_by_class()
```

### Reusable Utility Functions in Main Plugin

**Geometry:**
```python
def get_distance(self, p1, p2)  # 2D Euclidean distance (injected)
```

**Visualization:**
```python
def draw_error_marker(self, board, pos, message, layer, group)  # Circle + text (injected)
def draw_arrow(self, board, start, end, label, layer, group)  # Directional arrow (injected)
```

**Board Utilities:**
```python
def get_nets_by_class(self, board, class_name)  # Net Class â†’ net names (via auditor)
```

**Centralized Factories:**
```python
def create_logger(self, verbose, report_lines)  # Logger factory (injected)
def create_violation_group(self, board, check_type, ident, num)  # Group factory (injected)
```

**Always reuse these** - never reimplement in modules.

---

## ğŸ“ Logging Pattern for Modules (v1.3.0+)

### Centralized Logger (No Duplication)

**IMPORTANT**: Modules **DO NOT** implement their own `log()` method anymore. They receive a logger function via dependency injection.

**Main Plugin Creates Logger:**
```python
# File: emc_auditor_plugin.py
def check_your_module(self, board, marker_layer, config):
    verbose = self.config.get('general', {}).get('verbose_logging', True)
    
    # Create centralized logger
    log_func = self.create_logger(verbose, self.report_lines)
    
    # Pass to module
    violations = checker.check(
        ...,
        log_func=log_func,  # Inject logger
        ...
    )
```

**Module Receives and Uses Logger:**
```python
# File: your_module.py
class YourChecker:
    def __init__(self, board, marker_layer, config, report_lines, verbose=True, auditor=None):
        self.report_lines = report_lines  # Keep for reference
        self.verbose = verbose
        self.log = None  # Will be set during check() call
    
    def check(self, draw_marker_func, draw_arrow_func, get_distance_func, log_func, create_group_func):
        \"\"\"Receives logger via dependency injection\"\"\"
        # Store injected logger
        self.log = log_func
        
        # Use throughout module
        self.log("\\n=== YOUR CHECK START ===\", force=True)
        self.log(f"  Processing {count} items")  # Verbose only
        self.log(f"\\n=== COMPLETE: {violations} violation(s) ===\", force=True)
        
        return violations
```

### Logger Function Signature

```python
log_func(msg, force=False)
```

**Parameters:**
- `msg`: str - Message to log
- `force`: bool - If True, always print even if verbose=False (for summaries/errors)

### Usage Examples in Modules

```python
# Normal debug output (verbose mode only)
self.log("  Processing domain: HIGH_VOLTAGE (230V)")
self.log(f"  Found {len(features)} pads")

# Critical messages (always shown regardless of verbose)
self.log("\\n=== CLEARANCE CHECK START ===\", force=True)
self.log("âš ï¸  No nets assigned to voltage domains", force=True)
self.log("âŒ VIOLATION: Clearance too small", force=True)
self.log(f"\\n=== CHECK COMPLETE: {violations} violation(s) ===\", force=True)
```

### Report Line Format Conventions

```python
# Section headers (always visible)
self.log("\\n=== CLEARANCE CHECK START ===\", force=True)

# Subsection headers (verbose only)
self.log("\\n--- Parsing Voltage Domains ---")

# Info messages with indentation (verbose only)
self.log("  Processing domain: MAINS (230V)")
self.log(f"    âœ“ Assigned {count} nets via Net Class")

# Warnings (always visible)
self.log("âš ï¸  No clearance table found, using defaults", force=True)

# Violations (always visible)
self.log(f"  âŒ VIOLATION: {domain_a} â†” {domain_b}", force=True)
self.log(f"     Actual: {actual:.2f}mm, Required: {required:.2f}mm", force=True)

# Summary (always visible)
self.log(f"\\n=== CHECK COMPLETE: {violations} violation(s) ===\", force=True)
```

### Unicode Symbols for Consistency

Use these standard symbols across all modules:
- âœ… Success / checkmark
- âŒ Error / failure
- âš ï¸  Warning / attention
- âœ“ Completed step
- â†’ Arrow / direction
- â†” Bidirectional

**Benefits of Centralized Logger:**
- âœ… Zero code duplication (30 lines saved across 5 modules)
- âœ… Single place to modify logging behavior
- âœ… Consistent formatting across all checks
- âœ… Easy to add features (timestamps, log levels, file output)

---

## ğŸ”§ Step-by-Step: Creating a New Module

### 1. Create Module File

**File**: `your_check.py` (same directory as emc_auditor_plugin.py)

```python
"""
Your Check Module for EMC Auditor Plugin (v1.3.0+)
Implements [Standard/Feature Name] compliance checking

This module is called by emc_auditor_plugin.py and uses centralized utilities.
Configuration is read from emc_rules.toml [your_check] section.

Author: EMC Auditor Plugin
Version: 1.0.0
Last Updated: YYYY-MM-DD
"""

import pcbnew
import math


class YourChecker:
    """
    Handles [what this checker does].
    
    Standards supported:
    - [Standard Name]: [Brief description]
    """
    
    def __init__(self, board, marker_layer, config, report_lines, verbose=True, auditor=None):
        """
        Initialize checker with board context and configuration.
        
        Args:
            board: pcbnew.BOARD instance
            marker_layer: KiCad layer ID for drawing violation markers
            config: Dictionary from emc_rules.toml [your_check] section
            report_lines: List to append report messages (shared with main plugin)
            verbose: Enable detailed logging
            auditor: Reference to EMCAuditorPlugin instance (for utility functions)
        """
        self.board = board
        self.marker_layer = marker_layer
        self.config = config
        self.report_lines = report_lines
        self.verbose = verbose
        self.auditor = auditor
        
        # Centralized utility functions (injected during check() call)
        self.log = None  # Logger function (from main plugin)
        self.create_group = None  # Group creator function (from main plugin)
        self.draw_marker = None  # Marker drawing (from main plugin)
        self.draw_arrow = None  # Arrow drawing (from main plugin)
        self.get_distance = None  # Distance calculation (from main plugin)
        
        # Results tracking
        self.violation_count = 0
    
    def check(self, draw_marker_func, draw_arrow_func, get_distance_func, log_func, create_group_func):
        """
        Main entry point - performs verification.
        
        Called from emc_auditor_plugin.py check_your_check() method.
        Utility functions are injected to avoid code duplication.
        
        Args:
            draw_marker_func: Function(board, pos, msg, layer, group)
            draw_arrow_func: Function(board, start, end, label, layer, group)
            get_distance_func: Function(pos1, pos2) returns distance
            log_func: Function(msg, force=False) for logging (centralized)
            create_group_func: Function(board, check_type, identifier, number) creates PCB_GROUP
        
        Returns:
            int: Number of violations found
        """
        # Store injected utility functions
        self.log = log_func  # Centralized logger
        self.create_group = create_group_func  # Centralized group creator
        self.draw_marker = draw_marker_func
        self.draw_arrow = draw_arrow_func
        self.get_distance = get_distance_func
        
        self.log("\n=== YOUR CHECK START ===", force=True)
        
        # Your implementation here...
        
        self.log(f"\n=== YOUR CHECK COMPLETE: {self.violation_count} violation(s) ===", force=True)
        return self.violation_count


# Module metadata
__version__ = "1.0.0"
__author__ = "EMC Auditor Plugin"
__description__ = "Brief description of what this module checks"
```

### 2. Import Module in Main Plugin

**File**: `emc_auditor_plugin.py` (top of file)

```python
# Import your module
try:
    from your_check import YourChecker
except ImportError as e:
    print(f"WARNING: Could not import your_check module: {e}")
    YourChecker = None
```

### 3. Add Integration Method in Main Plugin (v1.3.0+)

```python
def check_your_feature(self, board, marker_layer, config):
    """Check [feature name] per [standard]
    
    This function delegates to the YourChecker module for implementation.
    Complete configuration is in emc_rules.toml [your_check] section.
    
    Returns:
        int: Number of violations found
    """
    # Check if module is available
    if YourChecker is None:
        print("âš ï¸  YourChecker module not available")
        print("HINT: Ensure your_check.py is in same directory as plugin")
        return 0
    
    # Create checker instance
    verbose = self.config.get('general', {}).get('verbose_logging', True)
    checker = YourChecker(
        board=board,
        marker_layer=marker_layer,
        config=config,
        report_lines=self.report_lines,
        verbose=verbose,
        auditor=self  # Pass self for utility access
    )
    
    # Create centralized utilities
    log_func = self.create_logger(verbose, self.report_lines)
    
    # Run check with injected utility functions  
    violations = checker.check(
        draw_marker_func=self.draw_error_marker,
        draw_arrow_func=self.draw_arrow,
        get_distance_func=self.get_distance,
        log_func=log_func,  # Centralized logger
        create_group_func=self.create_violation_group  # Centralized group creator
    )
    
    return violations
```

### 4. Register in Run() Method

```python
def Run(self):
    # ... existing code ...
    
    # Your new check
    your_check_cfg = self.config.get('your_check', {})
    if your_check_cfg.get('enabled', False):
        violations_found += self.check_your_feature(board, marker_layer, your_check_cfg)
```

### 5. Add Configuration to emc_rules.toml

```toml
[your_check]
enabled = false  # Start disabled for testing
description = "Brief description of check"
violation_message = "VIOLATION: Your check failed"

# Your specific parameters
parameter1 = 10.0
parameter2 = ["value1", "value2"]
```

### Module Checklist (v1.3.0+)

**Before committing:**
- [ ] Module file created with proper header docstring
- [ ] `__init__` receives all 6 parameters (board, marker_layer, config, report_lines, verbose, auditor)
- [ ] **NO** `log()` method implemented (uses centralized logger instead)
- [ ] `check()` method receives 5 injected functions (draw_marker, draw_arrow, get_distance, **log_func**, **create_group_func**)
- [ ] Module stores `self.log = log_func` at start of check()
- [ ] Module stores `self.create_group = create_group_func` at start of check()
- [ ] Uses `self.auditor.get_nets_by_class()` if needed
- [ ] Uses `self.create_group()` instead of manual PCB_GROUP creation
- [ ] Import added to main plugin with try/except
- [ ] Integration method created in main plugin
- [ ] Registered in `Run()` method
- [ ] Configuration section added to emc_rules.toml
- [ ] Documentation updated (README.md)
- [ ] Module synced to KiCad plugins directory (run `sync_to_kicad.ps1`)

---

## ğŸ”Œ Using Main Plugin Utility Functions in Modules

### Accessing Utilities via `self.auditor`

Modules receive `auditor=self` reference in `__init__`. This provides access to all main plugin utility functions.

### Available Utility Functions

#### 1. `get_nets_by_class(board, class_name)` - Net Class Lookup

**Purpose**: Get all nets belonging to a KiCad Net Class

**Example in module:**
```python
# Get all nets in "HIGH_VOLTAGE" net class
high_voltage_nets = self.auditor.get_nets_by_class(self.board, "HIGH_VOLTAGE")
# Returns: ['MAINS_L', 'MAINS_N', 'DC_BUS+', 'DC_BUS-']

# Get all nets in "SIGNAL" net class
signal_nets = self.auditor.get_nets_by_class(self.board, "SIGNAL")
```

**How it works:**
- Uses **substring matching** in net class names
- Handles comma-separated classes: `"HighSpeed,Default"` matches both `"HighSpeed"` and `"Default"`
- Case-sensitive: `"HIGH_VOLTAGE"` != `"high_voltage"`
- Returns empty list if no matches

**Real example from clearance_creepage.py:**
```python
def _parse_voltage_domains(self):
    for domain_config in voltage_domains:
        domain_name = domain_config.get('name', 'Unknown')
        
        # Try Net Class first (preferred method)
        nets_in_class = self.auditor.get_nets_by_class(self.board, domain_name)
        
        if nets_in_class:
            for net_name in nets_in_class:
                domain_map[net_name] = {
                    'domain_name': domain_name,
                    'voltage_rms': voltage_rms,
                    'source': 'net_class'
                }
            self.log(f"  âœ“ Assigned {len(nets_in_class)} net(s) via Net Class")
        else:
            # Fallback to pattern matching
            self.log(f"  âš  No nets in Net Class '{domain_name}', trying patterns")
```

**Best Practice**: Always prefer Net Classes over pattern matching. They're:
- More reliable (user-controlled in KiCad)
- More explicit (visible in Board Setup)
- Easier to maintain (no regex/wildcards)

#### 2. `get_distance(point1, point2)` - Distance Calculation

**Purpose**: Calculate 2D Euclidean distance between two points

**Injected during `check()` call (do NOT access via `self.auditor`):**
```python
def check(self, draw_marker_func, draw_arrow_func, get_distance_func):
    self.get_distance = get_distance_func  # Store for later use
    
    # Use in your check logic:
    distance = self.get_distance(pad1_pos, pad2_pos)  # Returns internal units
    distance_mm = pcbnew.ToMM(distance)  # Convert to millimeters
```

**Example from clearance_creepage.py:**
```python
def _calculate_clearance(self, features_a, features_b):
    for feature_a in features_a:
        pos_a = feature_a[2]  # Position
        for feature_b in features_b:
            pos_b = feature_b[2]
            
            # Use injected distance function
            distance = self.get_distance(pos_a, pos_b)
            
            if distance < min_distance:
                min_distance = distance
    
    # Convert to mm for display
    distance_mm = pcbnew.ToMM(min_distance)
    return distance_mm
```

#### 3. `draw_error_marker(board, pos, message, layer, group)` - Violation Marker

**Purpose**: Draw circle + text at violation location

**Injected during `check()` call:**
```python
def check(self, draw_marker_func, draw_arrow_func, get_distance_func):
    self.draw_marker = draw_marker_func  # Store
    
    # Create violation group first
    violation_group = pcbnew.PCB_GROUP(self.board)
    violation_group.SetName(f"EMC_YourCheck_{item_id}_{self.violation_count}")
    self.board.Add(violation_group)
    
    # Draw marker
    self.draw_marker(
        self.board,
        violation_position,  # pcbnew.VECTOR2I
        "VIOLATION: Distance too small\n2.5mm < 3.0mm",  # Multi-line OK
        self.marker_layer,
        violation_group
    )
```

**Marker appearance:**
- Red circle (0.8mm radius, configurable)
- Text label offset 1.2mm above circle
- Text size 0.5mm (configurable)

#### 4. `draw_arrow(board, start, end, label, layer, group)` - Directional Arrow

**Purpose**: Draw arrow from violation to related component

**Injected during `check()` call:**
```python
def check(self, draw_marker_func, draw_arrow_func, get_distance_func):
    self.draw_arrow = draw_arrow_func  # Store
    
    # Draw arrow from violation to target
    self.draw_arrow(
        self.board,
        violation_pos,    # Start point
        target_pos,       # End point (component location)
        "â†’ C15",          # Optional label
        self.marker_layer,
        violation_group
    )
```

**Arrow appearance:**
- Line with 0.5mm arrowhead
- Optional text label at midpoint
- Same line width as marker circle

### Usage Pattern Summary (v1.3.0+)

```python
class YourChecker:
    def __init__(self, ..., auditor=None):
        self.auditor = auditor  # Store reference
        # Centralized utilities (set during check())
        self.log = None
        self.create_group = None
        self.draw_marker = None
        self.draw_arrow = None
        self.get_distance = None
    
    def check(self, draw_marker_func, draw_arrow_func, get_distance_func, log_func, create_group_func):
        # Store injected functions
        self.log = log_func  # Centralized logger
        self.create_group = create_group_func  # Centralized group creator
        self.draw_marker = draw_marker_func
        self.draw_arrow = draw_arrow_func
        self.get_distance = get_distance_func
        
        self.log("\\n=== CHECK START ===\", force=True)
        
        # Use auditor for Net Class lookup
        nets = self.auditor.get_nets_by_class(self.board, "HighSpeed")
        
        # Use injected functions for geometry and visualization
        distance = self.get_distance(pos1, pos2)
        
        # When violation found - use centralized group creator
        violation_group = self.create_group(self.board, "YourCheck", identifier, violation_num)
        self.draw_marker(self.board, pos, "VIOLATION", layer, violation_group)
        self.draw_arrow(self.board, start, end, "â†’ Target", layer, violation_group)
        
        self.log(f"\\n=== COMPLETE: {violations} violation(s) ===\", force=True)
```

**Three access patterns:**
- `self.auditor.X()` - Functions that query board state (e.g., get_nets_by_class)
- `self.log()` - Centralized logger (eliminates duplicate log() methods)
- `self.create_group()` - Centralized group creator (eliminates boilerplate)
- `self.X()` - Visualization/geometry functions (draw_marker, draw_arrow, get_distance)

This separation makes testing easier and eliminates code duplication across modules.

---

### Current Implementation Status

**âœ… Implemented Rules:**
1. **Via Stitching** - Ensures GND return vias near high-speed signal vias
2. **Decoupling Capacitors** - Verifies caps near IC power pins (smart net matching)
3. **Ground Plane Continuity** - Checks continuous ground under/around high-speed traces
4. **EMI Filtering** - Verifies EMI filters on interface connectors (Pi, T, LC topologies)
5. **Clearance/Creepage** - Electrical safety verification (IEC60664-1)

**âœ… Refactored (v1.3.0 - February 12, 2026):**
- Centralized logger utility (30 lines replaces 5x6 = 30 lines duplicate code)
- Centralized group creator utility (36 lines replaces 40+ 3-line instances = 120+ lines)
- Net code reduction: ~104 lines saved

**ğŸš§ Configuration Ready (Implementation Pending):**
- Trace Width (current capacity)
- Differential Pairs (length matching)
- High-Speed Signals (stub length, bend radius)
- EMI Filtering (ferrite bead placement)

---

## CRITICAL RULE: Violation Marker Pattern (v1.3.0+)

**ALL DRC checks MUST follow this exact pattern:**

### 1. Create Individual Violation Group (Centralized Utility)

**Use centralized group creator (NO manual boilerplate):**
```python
# âœ… CORRECT (v1.3.0+): Use centralized utility
violation_group = self.create_group(
    self.board,
    "Via",  # Check type: Via, Decap, GndPlane, EMI, Clearance
    net_name,  # Identifier: net name, component ref, pad number, etc.
    self.violation_count + 1  # Sequence number (optional)
)
```

**âŒ WRONG (Old pattern): DON'T manually create groups**
```python
# âŒ Don't do this anymore (pre-v1.3.0 pattern)
violation_group = pcbnew.PCB_GROUP(board)
violation_group.SetName(f"EMC_{RuleCategory}_{ItemID}_{violations+1}")
board.Add(violation_group)
```

**Group Naming Examples (auto-generated by centralized utility):**
- `EMC_Decap_U1_VCC_5` - Decoupling check on IC U1, VCC net, violation #5
- `EMC_Via_CLK_15` - Via stitching on CLK net, violation #15
- `EMC_GndPlane_HSDATA_3` - Ground plane check on HSDATA net, violation #3
- `EMC_Clearance_MAINS_SELV_1` - Clearance violation between MAINS and SELV domains

**Why centralized utility:**
- âœ… Consistent naming across all checks
- âœ… Single place to modify group creation logic
- âœ… Eliminates 3-line boilerplate repeated 40+ times
- âœ… Guarantees "EMC_" prefix for cleanup

### 2. Draw Error Marker (Circle + Text)
```python
self.draw_marker(  # Note: might be self.draw_marker or draw_marker_func depending on context
    self.board,
    violation_position,     # pcbnew.VECTOR2I
    "VIOLATION MESSAGE",    # Can include {distance:.1f} placeholder
    self.marker_layer,
    violation_group  # Group created by centralized utility
)
```

**Result:** Red circle (0.8mm radius) + text label at violation location

### 3. Draw Arrow to Related Component (OPTIONAL)
```python
if config.get('draw_arrow_to_target', True):
    self.draw_arrow(  # Or draw_arrow_func depending on context
        self.board,
        start_position,      # Where violation is
        target_position,     # Related component location
        "â†’ TARGET_REF",      # Arrow label (e.g., "â†’ C15")
        self.marker_layer,
        violation_group  # Same group as marker
    )
```

**Result:** Arrow with 0.5mm arrowhead pointing from violation to related item

**Complete Example (v1.3.0 pattern):**
```python
def check(self, ..., log_func, create_group_func):
    self.log = log_func
    self.create_group = create_group_func
    
    # When violation found:
    violation_group = self.create_group(
        self.board,
        "Decap",  # Check type
        f\"{ic_ref}_{net_name}\",  # Identifier
        self.violation_count + 1  # Sequence number
    )
    
    self.draw_marker(
        self.board,
        ic_pad_pos,
        f\"CAP TOO FAR ({distance:.1f}mm)\",
        self.marker_layer,
        violation_group
    )
    
    if nearest_cap:
        self.draw_arrow(
            self.board,
            ic_pad_pos,
            nearest_cap_pos,
            f\"â†’ {nearest_cap_ref}\",
            self.marker_layer,
            violation_group
        )
    
    self.violation_count += 1
```

---

## Configuration File Integration

**File**: `emc_rules.toml`  
**Format**: TOML (parsed with tomllib/tomli/toml)

**Minimum Required Parameters:**
```toml
[your_rule]
enabled = true                    # REQUIRED: Enable/disable check
description = "What it checks"    # REQUIRED: Documentation
violation_message = "TEXT HERE"   # REQUIRED: What to display

# Rule-specific logic parameters (customize as needed)
max_distance_mm = 2.0
net_classes = ["HighSpeed", "Clock"]
net_patterns = ["VCC", "GND"]

# Optional visual enhancements
draw_arrow_to_target = true
show_target_label = true
```

---

## Template for New DRC Rule

```python
def check_your_rule(self, board, marker_layer, config):
    """
    Template for new DRC rule implementation
    
    Args:
        board: pcbnew.BOARD object
        marker_layer: Layer ID for User.Comments
        config: dict from emc_rules.toml [your_rule] section
    
    Returns:
        int: Number of violations found
    """
    # Parse config parameters
    max_dist = pcbnew.FromMM(config.get('max_distance_mm', 2.0))
    net_classes = config.get('critical_net_classes', ['HighSpeed'])
    violation_msg = config.get('violation_message', 'VIOLATION FOUND')
    draw_arrow = config.get('draw_arrow_to_target', True)
    
    violations = 0
    
    # Get items to check
    items_to_check = self.get_items_for_check(board, net_classes)
    
    if not items_to_check:
        print(f"WARNING: No items found for [your_rule]. Skipping.")
        return 0
    
    # Check each item
    for item in items_to_check:
        if self.detect_violation(item):
            # Step 1: Create group
            violation_group = pcbnew.PCB_GROUP(board)
            violation_group.SetName(f"EMC_YourRule_{item.GetNetname()}_{violations+1}")
            board.Add(violation_group)
            
            # Step 2: Draw circle + text
            violation_pos = item.GetPosition()
            self.draw_error_marker(
                board, 
                violation_pos, 
                violation_msg, 
                marker_layer, 
                violation_group
            )
            
            # Step 3 (optional): Draw arrow
            if draw_arrow:
                target_pos = self.find_related_component(item)
                if target_pos:
                    self.draw_arrow(
                        board,
                        violation_pos,
                        target_pos,
                        f"â†’ {item.GetReference()}",
                        marker_layer,
                        violation_group
                    )
            
            violations += 1
    
    return violations
```

---

## Existing Helper Functions (DO NOT REIMPLEMENT)

```python
# Distance calculation (2D Euclidean)
distance = self.get_distance(point1, point2)  # Returns internal units

# Draw violation markers
self.draw_error_marker(board, pos, message, layer, group)
self.draw_arrow(board, start_pos, end_pos, label, layer, group)

# Clear old markers before run
self.clear_previous_markers(board)

# Unit conversions
internal_units = pcbnew.FromMM(mm_value)
mm_value = pcbnew.ToMM(internal_units)
```

---

## Registration in Run() Method

**ALWAYS register your check in the Run() method:**

```python
def Run(self):
    board = pcbnew.GetBoard()
    self.clear_previous_markers(board)
    
    general = self.config.get('general', {})
    marker_layer = board.GetLayerID(general.get('marker_layer', 'Cmts.User'))
    
    violations_found = 0
    
    # Existing checks...
    via_cfg = self.config.get('via_stitching', {})
    if via_cfg.get('enabled', True):
        violations_found += self.check_via_stitching(board, marker_layer, via_cfg)
    
    # YOUR NEW CHECK HERE:
    your_rule_cfg = self.config.get('your_rule', {})
    if your_rule_cfg.get('enabled', False):  # Default: disabled for new rules
        violations_found += self.check_your_rule(board, marker_layer, your_rule_cfg)
    
    pcbnew.Refresh()
    print(f"EMC Audit Complete. Found {violations_found} violation(s).")
```

---

## Visual Consistency Requirements

**All markers MUST use these dimensions:**
- Circle radius: `0.8mm` (from config `marker_circle_radius_mm`)
- Line width: `0.1mm` (from config `marker_line_width_mm`)
- Text size: `0.5mm` (from config `marker_text_size_mm`)
- Text offset: `1.2mm` (from config `marker_text_offset_mm`)
- Arrow head: `0.5mm` length (hardcoded in `draw_arrow()`)

**Layer**: Always `User.Comments` (Cmts.User)

**Colors**: KiCad manages layer colors - plugin draws shapes only

---

## Error Handling Pattern

```python
try:
    # Your checking logic
    if not required_data:
        print(f"WARNING: Missing data for [your_rule]. Skipping check.")
        return 0
    
    # Perform checks...
    
except Exception as e:
    print(f"ERROR in [your_rule] check: {e}")
    import traceback
    traceback.print_exc()
    return 0
```

---

## Testing Checklist

Before committing new DRC rule:

- [ ] Rule has `enabled = true/false` toggle in config
- [ ] Violation markers visible on User.Comments layer
- [ ] Each violation has unique group name starting with "EMC_"
- [ ] Right-click marker â†’ "Select Items in Group" selects all markers
- [ ] Re-running plugin clears old markers
- [ ] Console prints "Found X violation(s)"
- [ ] README.md updated with usage example and visualization
- [ ] Config file includes properly documented template

---

## Common Pitfalls to Avoid (v1.3.0+)

âŒ **WRONG:** Creating one group for all violations
```python
# Don't do this:
violation_group = self.create_group(self.board, "Check", "violation", 1)
for item in items:
    self.draw_marker(...)  # All in same group - can't select individually
```

âœ… **CORRECT:** Create individual group per violation (v1.3.0 pattern)
```python
# Do this:
for item in items:
    violation_group = self.create_group(  # New group per violation
        self.board,
        "Check",
        item.identifier,
        self.violation_count + 1
    )
    self.draw_marker(..., violation_group)
    self.violation_count += 1
```

âŒ **WRONG:** Manually creating groups (pre-v1.3.0 pattern)
```python
# Don't do this anymore:
violation_group = pcbnew.PCB_GROUP(board)  # Manual group creation
violation_group.SetName(f"EMC_Via_{net}_{n}")
board.Add(violation_group)
```

âœ… **CORRECT:** Use centralized group creator (v1.3.0+)
```python
# Do this instead:
violation_group = self.create_group(  # Centralized utility
    self.board,
    "Via",  # Check type
    net,  # Identifier
    n  # Sequence number
)
```

âŒ **WRONG:** Implementing log() method in module
```python
# Don't do this anymore (pre-v1.3.0 pattern):
class YourChecker:
    def log(self, msg, force=False):  # Duplicate code!
        if self.verbose or force:
            print(msg)
            if self.verbose:
                self.report_lines.append(msg)
```

âœ… **CORRECT:** Use injected logger (v1.3.0+)
```python
# Do this instead:
class YourChecker:
    def __init__(self, ...):
        self.log = None  # Will receive centralized logger
    
    def check(self, ..., log_func, ...):
        self.log = log_func  # Store injected logger
        self.log("Processing...")  # Use throughout module
```

âŒ **WRONG:** Hardcoding marker dimensions
```python
radius = 800000  # Don't hardcode internal units
```

âœ… **CORRECT:** Use config values
```python
radius = pcbnew.FromMM(self.config['general']['marker_circle_radius_mm'])
```

âŒ **WRONG:** Missing "EMC_" prefix in group names
```python
violation_group.SetName(f"Violation_{n}")  # Won't be cleaned up properly
```

âœ… **CORRECT:** Use centralized utility (guarantees correct prefix)
```python
violation_group = self.create_group(board, "Check", identifier, n)
# Automatically creates: "EMC_Check_identifier_n"
```

---

## Performance Guidelines

- **Avoid O(nÂ³)** - Keep checks O(nÂ²) or better
- **Cache layer lookups** - Call `board.GetLayerID()` once
- **Spatial indexing** - Group items by layer before distance checks
- **Conditional arrows** - Only draw if `draw_arrow = true` in config
- **Early returns** - Exit if no items to check
- **Use centralized utilities** - Avoid recreating logger/group functions in loops

---

## Files to Modify When Adding New Rule

1. **emc_auditor_plugin.py**
   - Add `check_your_rule()` method with centralized utility injection
   - Register in `Run()` method
   - Update `get_default_config()` if needed
   - **NO NEED** to add new helper functions (use existing centralized utilities)

2. **emc_rules.toml**
   - Add `[your_rule]` section with parameters
   - Document all config options with comments

3. **README.md**
   - Add usage example to "Usage" section
   - Update "Implemented Rules" or "Planned Rules" table
   - Add visualization example if pattern differs

4. **YOUR_RULE.md** (optional)
   - Create detailed documentation if rule is complex
   - Include implementation rationale and EMC theory

5. **sync_to_kicad.ps1**
   - New module files will be automatically copied if in root directory
   - Test with `.\sync_to_kicad.ps1` before committing

---

## Priority Order for Future Implementation

Based on `emc_rules.toml` configuration:

1. **Trace Width** - Power trace current capacity (IPC-2221)
2. **Clearance/Creepage** - High-voltage safety (IEC60664-1)
3. **Differential Pairs** - Length matching, impedance control
4. **High-Speed Signals** - Stub length, bend radius, via count
5. **EMI Filtering** - Ferrite bead/filter placement on interfaces

All use the **same marker visualization pattern**.

---

## Questions or Issues?

- **Plugin Architecture**: See `EMCAuditorPlugin` class in `emc_auditor_plugin.py`
- **Marker Drawing**: See `draw_error_marker()` and `draw_arrow()` methods
- **Config Parsing**: See `load_config()` and `get_default_config()` methods
- **Examples**: Study `check_via_stitching()`, `check_decoupling()`, `check_ground_plane()`

**License**: MIT License  
**KiCad Version**: 9.0.7+  
**Python Version**: 3.8+ (requires tomli/toml for Python < 3.11)
