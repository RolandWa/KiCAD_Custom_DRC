# EMC Auditor Plugin - AI Development Guide

**Repository**: KiCAD_Custom_DRC | **Plugin**: emc_auditor_plugin.py | **Version**: 1.3.0 | **Updated**: Feb 12, 2026

---

## üéØ Quick Context

KiCad PCB plugin for EMC/DRC verification using **modular architecture** with **dependency injection**. Main plugin (899 lines) coordinates 5 checker modules (via_stitching, decoupling, emi_filtering, ground_plane, clearance_creepage).

**Architecture Highlights (v1.3.0):**
- ‚úÖ **Centralized utilities**: `create_logger()`, `create_violation_group()` eliminate 170+ lines of duplicate code
- ‚úÖ **Dependency injection**: Modules receive logger, group creator, visualization functions
- ‚úÖ **Modular design**: Each checker is a separate class (150-700 lines)
- ‚úÖ **Standardized markers**: All violations use EMC_* named groups on User.Comments layer

---

## üêç Python Code Quality Standards

### CRITICAL: Follow These Patterns

**1. Type Hints (Always Use)**
```python
def check(self, draw_marker_func: callable, draw_arrow_func: callable, 
          get_distance_func: callable, log_func: callable, 
          create_group_func: callable) -> int:
    """Main entry point with explicit return type."""
    pass
```

**2. Docstrings (Required for All Public Methods)**
```python
def get_nets_by_class(self, board: pcbnew.BOARD, class_name: str) -> list[str]:
    """
    Get all nets belonging to a Net Class (substring match).
    
    Args:
        board: KiCad BOARD instance
        class_name: Net class name (handles comma-separated: "HighSpeed,Default")
    
    Returns:
        list: Net names (strings) in this class
    
    Example:
        >>> nets = self.get_nets_by_class(board, "HighSpeed")
        >>> # Returns: ['CLK', 'DATA+', 'DATA-']
    """
    pass
```

**3. Error Handling (Defensive Programming)**
```python
def check_decoupling(self, board, marker_layer, config):
    """Always wrap module execution in try/except."""
    if DecouplingChecker is None:
        print("‚ö†Ô∏è  Module not available")
        return 0
    
    try:
        checker = DecouplingChecker(...)
        return checker.check(...)
    except Exception as e:
        print(f"‚ùå ERROR in decoupling check: {e}")
        import traceback
        traceback.print_exc()
        return 0  # Fail gracefully
```

**4. Constants (Use UPPER_CASE)**
```python
# At module level
DEFAULT_MAX_DISTANCE_MM = 2.0
GROUND_NET_PATTERNS = ['GND', 'GROUND', 'VSS', 'PGND', 'AGND']
POWER_NET_PATTERNS = ['VCC', 'VDD', 'PWR', '3V3', '5V', '1V8']

# In methods
max_dist = pcbnew.FromMM(config.get('max_distance_mm', DEFAULT_MAX_DISTANCE_MM))
```

**5. List Comprehensions (Pythonic Style)**
```python
# ‚úÖ GOOD: Pythonic, readable
critical_vias = [v for v in vias if v.GetNetname() in critical_nets]
ground_vias = [v for v in vias if any(pat in v.GetNetname().upper() for pat in GROUND_PATTERNS)]

# ‚ùå BAD: Verbose loop
critical_vias = []
for v in vias:
    if v.GetNetname() in critical_nets:
        critical_vias.append(v)
```

**6. Early Returns (Reduce Nesting)**
```python
# ‚úÖ GOOD: Early exit pattern
def check(self, ...):
    if not items_to_check:
        self.log("‚ö†Ô∏è  No items found, skipping", force=True)
        return 0
    
    for item in items_to_check:
        if not self._is_valid(item):
            continue
        # Main logic here (flat, not nested)

# ‚ùå BAD: Deep nesting
def check(self, ...):
    if items_to_check:
        for item in items_to_check:
            if self._is_valid(item):
                # Logic deeply nested
```

**7. String Formatting (Use f-strings)**
```python
# ‚úÖ GOOD: f-strings (Python 3.6+)
self.log(f"Found {len(vias)} vias on net '{net_name}'")
message = f"CAP TOO FAR ({distance:.1f}mm > {limit:.1f}mm)"

# ‚ùå BAD: Old .format() or % formatting
self.log("Found {} vias on net '{}'".format(len(vias), net_name))
```

**8. Context Managers (Resource Safety)**
```python
# If reading files (not common in plugin, but good practice)
try:
    config_path = Path(__file__).parent / "emc_rules.toml"
    with open(config_path, 'rb') as f:
        config = tomllib.load(f)
except FileNotFoundError:
    print("‚ö†Ô∏è  Config file not found, using defaults")
```

**9. None Checks (Explicit is Better)**
```python
# ‚úÖ GOOD: Explicit None check
if nearest_cap is None:
    self.log("‚ùå No capacitor found", force=True)
    return float('inf')

# ‚ùå BAD: Implicit truthiness (can fail for 0, [], False)
if not nearest_cap:  # Dangerous if nearest_cap could be 0 or empty list
    pass
```

**10. Private Methods (Use Leading Underscore)**
```python
class DecouplingChecker:
    def check(self, ...) -> int:
        """Public API method."""
        return self._perform_check()
    
    def _perform_check(self) -> int:
        """Internal implementation (not called from main plugin)."""
        pass
    
    def _calculate_distance(self, pos1, pos2) -> float:
        """Internal helper method."""
        pass
```

---

## üèóÔ∏è Module Architecture Pattern

### Checker Module Template

```python
"""
Module Name - Brief Description
Implements [Standard] compliance for KiCad PCB designs.
"""
import pcbnew
from typing import Callable

class YourChecker:
    """Checker for [specific EMC rule]."""
    
    def __init__(self, board: pcbnew.BOARD, marker_layer: int, config: dict, 
                 report_lines: list[str], verbose: bool = True, auditor = None):
        """
        Initialize checker.
        
        Args:
            board: KiCad BOARD instance
            marker_layer: Layer ID for violation markers (User.Comments)
            config: Configuration dict from emc_rules.toml [your_section]
            report_lines: Shared report list (modified in-place)
            verbose: Enable detailed logging
            auditor: Reference to EMCAuditorPlugin (access to get_nets_by_class, etc.)
        """
        self.board = board
        self.marker_layer = marker_layer
        self.config = config
        self.report_lines = report_lines
        self.verbose = verbose
        self.auditor = auditor
        
        # Injected utilities (set during check() call)
        self.log: Callable[[str, bool], None] = None
        self.create_group: Callable = None
        self.draw_marker: Callable = None
        self.draw_arrow: Callable = None
        self.get_distance: Callable = None
        
        self.violation_count = 0
    
    def check(self, draw_marker_func: callable, draw_arrow_func: callable, 
              get_distance_func: callable, log_func: callable, 
              create_group_func: callable) -> int:
        """
        Main entry point.
        
        Args:
            draw_marker_func: Function(board, pos, msg, layer, group)
            draw_arrow_func: Function(board, start, end, label, layer, group)
            get_distance_func: Function(pos1, pos2) -> float (internal units)
            log_func: Function(msg, force=False) for logging
            create_group_func: Function(board, type, id, num) -> PCB_GROUP
        
        Returns:
            Number of violations found
        """
        # Store injected utilities
        self.log = log_func
        self.create_group = create_group_func
        self.draw_marker = draw_marker_func
        self.draw_arrow = draw_arrow_func
        self.get_distance = get_distance_func
        
        self.log("\n=== YOUR CHECK START ===", force=True)
        
        # Get configuration
        max_dist_mm = self.config.get('max_distance_mm', 2.0)
        max_dist = pcbnew.FromMM(max_dist_mm)
        
        # Perform checks
        try:
            items = self._get_items_to_check()
            if not items:
                self.log("‚ö†Ô∏è  No items found", force=True)
                return 0
            
            for item in items:
                if self._has_violation(item, max_dist):
                    self._create_violation_marker(item)
        
        except Exception as e:
            self.log(f"‚ùå ERROR: {e}", force=True)
            import traceback
            traceback.print_exc()
        
        self.log(f"\n=== COMPLETE: {self.violation_count} violation(s) ===", force=True)
        return self.violation_count
    
    def _get_items_to_check(self) -> list:
        """Internal: Get items requiring verification."""
        pass
    
    def _has_violation(self, item, threshold) -> bool:
        """Internal: Check if item violates rule."""
        pass
    
    def _create_violation_marker(self, item):
        """Internal: Create violation group and markers."""
        violation_group = self.create_group(
            self.board,
            "YourCheck",  # Check type
            item.identifier,  # Unique identifier
            self.violation_count + 1
        )
        
        self.draw_marker(
            self.board,
            item.position,
            f"VIOLATION: {item.reason}",
            self.marker_layer,
            violation_group
        )
        
        self.violation_count += 1
```

### Main Plugin Integration

```python
# In emc_auditor_plugin.py

# 1. Import module
try:
    from your_module import YourChecker
except ImportError as e:
    print(f"‚ö†Ô∏è  Could not import your_module: {e}")
    YourChecker = None

# 2. Add delegation method
def check_your_feature(self, board, marker_layer, config):
    """Check [feature] per [standard]."""
    if YourChecker is None:
        return 0
    
    try:
        verbose = self.config.get('general', {}).get('verbose_logging', True)
        checker = YourChecker(board, marker_layer, config, 
                             self.report_lines, verbose, self)
        
        # Create centralized utilities
        log_func = self.create_logger(verbose, self.report_lines)
        
        # Inject utilities and run
        return checker.check(
            draw_marker_func=self.draw_error_marker,
            draw_arrow_func=self.draw_arrow,
            get_distance_func=self.get_distance,
            log_func=log_func,
            create_group_func=self.create_violation_group
        )
    except Exception as e:
        print(f"‚ùå ERROR in your_feature check: {e}")
        return 0

# 3. Register in Run() method
def Run(self):
    # ... existing code ...
    your_cfg = self.config.get('your_check', {})
    if your_cfg.get('enabled', False):
        violations_found += self.check_your_feature(board, marker_layer, your_cfg)
```

---

## üîß Centralized Utilities (v1.3.0)

**Available in Main Plugin:**

```python
# 1. Logger factory
log_func = self.create_logger(verbose, report_lines)
# Returns: callable(msg, force=False)

# 2. Group creator
group = self.create_violation_group(board, "CheckType", "identifier", 1)
# Returns: PCB_GROUP with name "EMC_CheckType_identifier_1"

# 3. Distance calculation
distance = self.get_distance(pos1, pos2)  # Internal units

# 4. Visualization
self.draw_error_marker(board, pos, "MSG", layer, group)
self.draw_arrow(board, start, end, "‚Üí Label", layer, group)

# 5. Board utilities (via auditor)
nets = self.auditor.get_nets_by_class(board, "HighSpeed")
```

**Module Checklist:**
- [ ] Module implements `__init__` with 6 params: board, marker_layer, config, report_lines, verbose, auditor
- [ ] `check()` receives 5 injected functions: draw_marker, draw_arrow, get_distance, log_func, create_group_func
- [ ] **NO** `log()` method in module (use injected `log_func`)
- [ ] **NO** manual `PCB_GROUP()` creation (use injected `create_group_func`)
- [ ] Type hints on all public methods
- [ ] Docstrings with Args/Returns sections
- [ ] Private methods use `_leading_underscore`
- [ ] Try/except wrapper in `check()` method

---

## üìã Configuration Pattern

**emc_rules.toml:**
```toml
[your_check]
enabled = false  # Disable by default for new rules
description = "Brief description of what this checks"
violation_message = "VIOLATION TEXT"

# Rule-specific parameters
max_distance_mm = 2.0
net_classes = ["HighSpeed", "Clock"]
net_patterns = ["VCC", "GND"]

# Visual options
draw_arrow_to_target = true
show_distance_label = true
```

**Access in module:**
```python
max_dist_mm = self.config.get('max_distance_mm', 2.0)  # With default
net_classes = self.config.get('net_classes', ['HighSpeed'])
```

---

## üö´ Anti-Patterns (Common Mistakes)

### ‚ùå DON'T: Implement log() in modules
```python
# ‚ùå OLD PATTERN (pre-v1.3.0)
class YourChecker:
    def log(self, msg, force=False):  # DUPLICATE CODE!
        if self.verbose or force:
            print(msg)
```

### ‚úÖ DO: Use injected logger
```python
# ‚úÖ NEW PATTERN (v1.3.0+)
class YourChecker:
    def __init__(self, ...):
        self.log = None  # Set during check() call
    
    def check(self, ..., log_func, ...):
        self.log = log_func
        self.log("Processing...")
```

### ‚ùå DON'T: Manually create groups
```python
# ‚ùå OLD PATTERN
violation_group = pcbnew.PCB_GROUP(board)
violation_group.SetName(f"EMC_Via_{net}_{n}")
board.Add(violation_group)
```

### ‚úÖ DO: Use centralized utility
```python
# ‚úÖ NEW PATTERN
violation_group = self.create_group(board, "Via", net, n)
```

### ‚ùå DON'T: Deep nesting
```python
# ‚ùå BAD
for item in items:
    if condition1:
        if condition2:
            if condition3:
                # Logic here
```

### ‚úÖ DO: Early returns
```python
# ‚úÖ GOOD
for item in items:
    if not condition1:
        continue
    if not condition2:
        continue
    if not condition3:
        continue
    # Logic here (flat)
```

### ‚ùå DON'T: Hardcode dimensions
```python
# ‚ùå BAD
radius = 800000  # What unit? Magic number!
```

### ‚úÖ DO: Use config + named constants
```python
# ‚úÖ GOOD
radius = pcbnew.FromMM(self.config['general']['marker_circle_radius_mm'])
```

---

## üß™ Testing Guidelines

**Before Committing:**
1. **Syntax Check**: `python -m py_compile emc_auditor_plugin.py`
2. **Import Test**: Open Python REPL, try `from emc_auditor_plugin import EMCAuditorPlugin`
3. **KiCad Test**: 
   - Run `.\sync_to_kicad.ps1` to deploy
   - Restart KiCad (close ALL windows, including project manager)
   - Open test board (CSI_current_measurment.kicad_pcb)
   - Run plugin, verify expected violations
4. **Baseline Validation**: Compare violation counts to known baseline:
   - Via stitching: 0
   - Decoupling: 9
   - Ground plane: 4
   - EMI filtering: 22
   - Clearance: 4
   - **Total: 40 violations**

**Unit Tests (Future):**
```python
# tests/test_via_stitching.py
import unittest
from via_stitching import ViaStitchingChecker

class TestViaStitching(unittest.TestCase):
    def test_critical_via_detection(self):
        # Mock board, config, auditor
        pass
```

---

## üìä Performance Guidelines

1. **Avoid O(n¬≥)** - Use spatial indexing, hash maps
2. **Cache lookups** - Call `board.GetLayerID()` once, not in loops
3. **Early exit** - Return 0 if no items to check
4. **Lazy evaluation** - Don't compute distances unless needed
5. **List comprehensions** - Faster than manual loops for filtering

```python
# ‚úÖ GOOD: O(n) with set lookup
critical_nets_set = set(critical_nets)
critical_vias = [v for v in vias if v.GetNetname() in critical_nets_set]

# ‚ùå BAD: O(n¬≤) with list lookup
critical_vias = [v for v in vias if v.GetNetname() in critical_nets]  # Slow if critical_nets is large
```

---

## üìÇ File Structure

```
KiCAD_Custom_DRC/
‚îú‚îÄ‚îÄ emc_auditor_plugin.py       # Main plugin (899 lines)
‚îú‚îÄ‚îÄ via_stitching.py            # Via stitching checker (221 lines)
‚îú‚îÄ‚îÄ decoupling.py               # Decoupling checker (188 lines)
‚îú‚îÄ‚îÄ emi_filtering.py            # EMI filtering checker (697 lines)
‚îú‚îÄ‚îÄ ground_plane.py             # Ground plane checker (495 lines)
‚îú‚îÄ‚îÄ clearance_creepage.py       # Clearance checker (639 lines)
‚îú‚îÄ‚îÄ emc_rules.toml              # Configuration
‚îú‚îÄ‚îÄ emc_icon.png                # Plugin icon
‚îú‚îÄ‚îÄ sync_to_kicad.ps1           # Deployment script
‚îú‚îÄ‚îÄ README.md                   # User documentation
‚îú‚îÄ‚îÄ CODE_REUSABILITY_ANALYSIS.md  # Code quality analysis
‚îî‚îÄ‚îÄ .copilot-instructions.md    # This file
```

---

## üé® Violation Marker Pattern

**Standard Flow:**
```python
# 1. Create group (one line)
violation_group = self.create_group(self.board, "CheckType", identifier, violation_num)

# 2. Draw marker (always)
self.draw_marker(self.board, pos, "VIOLATION MESSAGE", self.marker_layer, violation_group)

# 3. Draw arrow (optional)
if self.config.get('draw_arrow_to_target', True):
    self.draw_arrow(self.board, start, end, "‚Üí C15", self.marker_layer, violation_group)

# 4. Increment counter
self.violation_count += 1
```

**Marker Appearance:**
- Red circle (0.8mm radius, configurable)
- Text label 1.2mm above circle
- Arrow with 0.5mm arrowhead (optional)
- All on User.Comments layer
- Grouped for easy selection/deletion

---

## üîí Security & Privacy

**NEVER commit:**
- ‚ùå Real names, usernames, emails
- ‚ùå Company names, internal project names
- ‚ùå Absolute paths with usernames (`C:\Users\JohnDoe\...`)
- ‚ùå IP addresses, VPN endpoints
- ‚ùå API keys, passwords, tokens

**ALWAYS use:**
- ‚úÖ Environment variables: `$env:USERPROFILE`, `%APPDATA%`
- ‚úÖ Placeholders: `<repository_path>`, `<user_home>`
- ‚úÖ Generic examples: `user@example.com`, `ExampleCorp`

---

## üìñ Documentation Standards

**File Headers:**
```python
"""
Module Name - Brief Description

Implements [Standard Name] compliance checking for KiCad PCB designs.
Verifies [what it checks] according to [standard] requirements.

Standards:
    - IEC60664-1: Electrical safety clearance/creepage
    - IPC-2221: PCB design standard

Configuration:
    See emc_rules.toml [module_name] section

Author: EMC Auditor Plugin Contributors
Version: 1.0.0
Last Updated: YYYY-MM-DD
"""
```

**Method Docstrings:**
```python
def method_name(self, param1: type1, param2: type2) -> return_type:
    """
    Brief one-line description.
    
    Longer description if needed. Explain edge cases, algorithm choice,
    performance characteristics, or complex logic.
    
    Args:
        param1: Description of parameter 1
        param2: Description of parameter 2
    
    Returns:
        Description of return value
    
    Raises:
        ValueError: When param1 is negative
        KeyError: When required config key missing
    
    Example:
        >>> result = obj.method_name(10, 20)
        >>> print(result)
        30
    """
    pass
```

---

## üéØ Summary: Key Principles

1. **No Code Duplication** - Use centralized utilities
2. **Type Hints Always** - Explicit is better than implicit
3. **Docstrings Required** - Every public method
4. **Early Returns** - Reduce nesting depth
5. **Pythonic Style** - List comprehensions, f-strings, context managers
6. **Error Handling** - Always wrap in try/except
7. **Private Methods** - Use `_leading_underscore` convention
8. **Constants** - Use UPPER_CASE at module level
9. **Testing** - Validate against 40-violation baseline
10. **Security** - Never commit sensitive data

**Target Metrics:**
- Line length: ‚â§ 100 characters
- Function length: ‚â§ 50 lines
- Cyclomatic complexity: ‚â§ 10
- Module length: 150-700 lines (extract if larger)

**License**: MIT | **KiCad Version**: 9.0.7+ | **Python Version**: 3.8+
