# EMC Auditor Plugin - AI Assistant Development Guide

**Repository**: KiCAD_Custom_DRC  
**Plugin**: emc_auditor_plugin.py  
**Purpose**: EMC/DRC verification for KiCad PCB designs

---

## Quick Context for AI Assistants

This plugin checks electromagnetic compatibility (EMC) rules on KiCad PCB designs. All violations are visualized using a **standardized marker pattern** on the User.Comments layer.

### Current Implementation Status

**‚úÖ Implemented Rules:**
1. **Via Stitching** - Ensures GND return vias near high-speed signal vias
2. **Decoupling Capacitors** - Verifies caps near IC power pins (smart net matching)
3. **Ground Plane Continuity** - Checks continuous ground under/around high-speed traces

**üöß Configuration Ready (Implementation Pending):**
- Clearance/Creepage (IEC60664-1/IPC2221)
- Trace Width (current capacity)
- Differential Pairs (length matching)
- High-Speed Signals (stub length, bend radius)
- EMI Filtering (ferrite bead placement)

---

## CRITICAL RULE: Violation Marker Pattern

**ALL DRC checks MUST follow this exact pattern:**

### 1. Create Individual Violation Group
```python
violation_group = pcbnew.PCB_GROUP(board)
violation_group.SetName(f"EMC_{RuleCategory}_{ItemID}_{violations+1}")
board.Add(violation_group)
```

**Group Naming Examples:**
- `EMC_Decap_U1_VCC` - Decoupling check on IC U1, VCC net
- `EMC_Via_15` - Via stitching violation #15
- `EMC_GndPlane_CLK_3` - Ground plane check on CLK net, violation #3

**Why:** Allows users to select/delete individual violations via "Select Items in Group"

### 2. Draw Error Marker (Circle + Text)
```python
self.draw_error_marker(
    board,
    violation_position,     # pcbnew.VECTOR2I
    "VIOLATION MESSAGE",    # Can include {distance:.1f} placeholder
    marker_layer,
    violation_group
)
```

**Result:** Red circle (0.8mm radius) + text label at violation location

### 3. Draw Arrow to Related Component (OPTIONAL)
```python
if config.get('draw_arrow_to_target', True):
    self.draw_arrow(
        board,
        start_position,      # Where violation is
        target_position,     # Related component location
        "‚Üí TARGET_REF",      # Arrow label (e.g., "‚Üí C15")
        marker_layer,
        violation_group
    )
```

**Result:** Arrow with 0.5mm arrowhead pointing from violation to related item

---

## Configuration File Integration

**File**: `emc_rules.toml`  
**Format**: TOML (parsed with tomllib/tomli/toml)

**Minimum Required Parameters:**
```toml
[your_rule]
enabled = true                    # REQUIRED: Enable/disable check
description = "What it checks"    # REQUIRED: Documentation
violation_message = "TEXT HERE"   # REQUIRED: What to display

# Rule-specific logic parameters (customize as needed)
max_distance_mm = 2.0
net_classes = ["HighSpeed", "Clock"]
net_patterns = ["VCC", "GND"]

# Optional visual enhancements
draw_arrow_to_target = true
show_target_label = true
```

---

## Template for New DRC Rule

```python
def check_your_rule(self, board, marker_layer, config):
    """
    Template for new DRC rule implementation
    
    Args:
        board: pcbnew.BOARD object
        marker_layer: Layer ID for User.Comments
        config: dict from emc_rules.toml [your_rule] section
    
    Returns:
        int: Number of violations found
    """
    # Parse config parameters
    max_dist = pcbnew.FromMM(config.get('max_distance_mm', 2.0))
    net_classes = config.get('critical_net_classes', ['HighSpeed'])
    violation_msg = config.get('violation_message', 'VIOLATION FOUND')
    draw_arrow = config.get('draw_arrow_to_target', True)
    
    violations = 0
    
    # Get items to check
    items_to_check = self.get_items_for_check(board, net_classes)
    
    if not items_to_check:
        print(f"WARNING: No items found for [your_rule]. Skipping.")
        return 0
    
    # Check each item
    for item in items_to_check:
        if self.detect_violation(item):
            # Step 1: Create group
            violation_group = pcbnew.PCB_GROUP(board)
            violation_group.SetName(f"EMC_YourRule_{item.GetNetname()}_{violations+1}")
            board.Add(violation_group)
            
            # Step 2: Draw circle + text
            violation_pos = item.GetPosition()
            self.draw_error_marker(
                board, 
                violation_pos, 
                violation_msg, 
                marker_layer, 
                violation_group
            )
            
            # Step 3 (optional): Draw arrow
            if draw_arrow:
                target_pos = self.find_related_component(item)
                if target_pos:
                    self.draw_arrow(
                        board,
                        violation_pos,
                        target_pos,
                        f"‚Üí {item.GetReference()}",
                        marker_layer,
                        violation_group
                    )
            
            violations += 1
    
    return violations
```

---

## Existing Helper Functions (DO NOT REIMPLEMENT)

```python
# Distance calculation (2D Euclidean)
distance = self.get_distance(point1, point2)  # Returns internal units

# Draw violation markers
self.draw_error_marker(board, pos, message, layer, group)
self.draw_arrow(board, start_pos, end_pos, label, layer, group)

# Clear old markers before run
self.clear_previous_markers(board)

# Unit conversions
internal_units = pcbnew.FromMM(mm_value)
mm_value = pcbnew.ToMM(internal_units)
```

---

## Registration in Run() Method

**ALWAYS register your check in the Run() method:**

```python
def Run(self):
    board = pcbnew.GetBoard()
    self.clear_previous_markers(board)
    
    general = self.config.get('general', {})
    marker_layer = board.GetLayerID(general.get('marker_layer', 'Cmts.User'))
    
    violations_found = 0
    
    # Existing checks...
    via_cfg = self.config.get('via_stitching', {})
    if via_cfg.get('enabled', True):
        violations_found += self.check_via_stitching(board, marker_layer, via_cfg)
    
    # YOUR NEW CHECK HERE:
    your_rule_cfg = self.config.get('your_rule', {})
    if your_rule_cfg.get('enabled', False):  # Default: disabled for new rules
        violations_found += self.check_your_rule(board, marker_layer, your_rule_cfg)
    
    pcbnew.Refresh()
    print(f"EMC Audit Complete. Found {violations_found} violation(s).")
```

---

## Visual Consistency Requirements

**All markers MUST use these dimensions:**
- Circle radius: `0.8mm` (from config `marker_circle_radius_mm`)
- Line width: `0.1mm` (from config `marker_line_width_mm`)
- Text size: `0.5mm` (from config `marker_text_size_mm`)
- Text offset: `1.2mm` (from config `marker_text_offset_mm`)
- Arrow head: `0.5mm` length (hardcoded in `draw_arrow()`)

**Layer**: Always `User.Comments` (Cmts.User)

**Colors**: KiCad manages layer colors - plugin draws shapes only

---

## Error Handling Pattern

```python
try:
    # Your checking logic
    if not required_data:
        print(f"WARNING: Missing data for [your_rule]. Skipping check.")
        return 0
    
    # Perform checks...
    
except Exception as e:
    print(f"ERROR in [your_rule] check: {e}")
    import traceback
    traceback.print_exc()
    return 0
```

---

## Testing Checklist

Before committing new DRC rule:

- [ ] Rule has `enabled = true/false` toggle in config
- [ ] Violation markers visible on User.Comments layer
- [ ] Each violation has unique group name starting with "EMC_"
- [ ] Right-click marker ‚Üí "Select Items in Group" selects all markers
- [ ] Re-running plugin clears old markers
- [ ] Console prints "Found X violation(s)"
- [ ] README.md updated with usage example and visualization
- [ ] Config file includes properly documented template

---

## Common Pitfalls to Avoid

‚ùå **WRONG:** Creating one group for all violations
```python
# Don't do this:
violation_group = pcbnew.PCB_GROUP(board)
board.Add(violation_group)
for item in items:
    self.draw_error_marker(...)  # All in same group
```

‚úÖ **CORRECT:** Create individual group per violation
```python
# Do this:
for item in items:
    violation_group = pcbnew.PCB_GROUP(board)  # New group per violation
    board.Add(violation_group)
    self.draw_error_marker(...)
```

‚ùå **WRONG:** Hardcoding marker dimensions
```python
radius = 800000  # Don't hardcode internal units
```

‚úÖ **CORRECT:** Use config values
```python
radius = pcbnew.FromMM(self.config['general']['marker_circle_radius_mm'])
```

‚ùå **WRONG:** Missing group name prefix
```python
violation_group.SetName(f"Violation_{n}")  # Won't be cleaned up properly
```

‚úÖ **CORRECT:** Use "EMC_" prefix
```python
violation_group.SetName(f"EMC_YourRule_{n}")  # Cleaned by clear_previous_markers()
```

---

## Performance Guidelines

- **Avoid O(n¬≥)** - Keep checks O(n¬≤) or better
- **Cache layer lookups** - Call `board.GetLayerID()` once
- **Spatial indexing** - Group items by layer before distance checks
- **Conditional arrows** - Only draw if `draw_arrow = true` in config
- **Early returns** - Exit if no items to check

---

## Files to Modify When Adding New Rule

1. **emc_auditor_plugin.py**
   - Add `check_your_rule()` method
   - Register in `Run()` method
   - Update `get_default_config()` if needed

2. **emc_rules.toml**
   - Add `[your_rule]` section with parameters
   - Document all config options with comments

3. **README.md**
   - Add usage example to "Usage" section
   - Update "Implemented Rules" or "Planned Rules" table
   - Add visualization example if pattern differs

4. **YOUR_RULE.md** (optional)
   - Create detailed documentation if rule is complex
   - Include implementation rationale and EMC theory

---

## Priority Order for Future Implementation

Based on `emc_rules.toml` configuration:

1. **Trace Width** - Power trace current capacity (IPC-2221)
2. **Clearance/Creepage** - High-voltage safety (IEC60664-1)
3. **Differential Pairs** - Length matching, impedance control
4. **High-Speed Signals** - Stub length, bend radius, via count
5. **EMI Filtering** - Ferrite bead/filter placement on interfaces

All use the **same marker visualization pattern**.

---

## Questions or Issues?

- **Plugin Architecture**: See `EMCAuditorPlugin` class in `emc_auditor_plugin.py`
- **Marker Drawing**: See `draw_error_marker()` and `draw_arrow()` methods
- **Config Parsing**: See `load_config()` and `get_default_config()` methods
- **Examples**: Study `check_via_stitching()`, `check_decoupling()`, `check_ground_plane()`

**License**: MIT License  
**KiCad Version**: 9.0.7+  
**Python Version**: 3.8+ (requires tomli/toml for Python < 3.11)
