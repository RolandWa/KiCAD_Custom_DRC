# EMC Auditor Plugin - AI Assistant Development Guide

**Repository**: KiCAD_Custom_DRC  
**Plugin**: emc_auditor_plugin.py  
**Version**: 1.3.0  
**Last Updated**: February 12, 2026  
**Purpose**: EMC/DRC verification for KiCad PCB designs

---

## Quick Context for AI Assistants

This plugin checks electromagnetic compatibility (EMC) rules on KiCad PCB designs using a **modular architecture** with dependency injection. All violations are visualized using a **standardized marker pattern** on the User.Comments layer.

**Current Modules (v1.3.0 - Refactored February 12, 2026):**
- `emc_auditor_plugin.py` - Main orchestrator (reduced to ~500 lines from 1172)
- `via_stitching.py` - Via stitching verification for EMI reduction (221 lines)
- `decoupling.py` - Decoupling capacitor proximity verification for signal integrity (188 lines)
- `emi_filtering.py` - EMI filtering verification on interface connectors (697 lines)
- `clearance_creepage.py` - Electrical clearance/creepage verification (639 lines stub)

---

## ðŸ—ï¸ Modular Architecture Pattern

### Overview

The plugin uses a **modular architecture** where complex DRC checks are separated into dedicated modules while reusing common utility functions from the main plugin. This avoids code duplication and keeps the codebase maintainable.

**Key Principle**: Main plugin owns visualization functions (draw markers, arrows), geometry functions (distance calculation), and board utilities (net class lookup). Modules use **dependency injection** to access these functions.

### Example: clearance_creepage.py Module

```python
# File: clearance_creepage.py
from clearance_creepage import ClearanceCreepageChecker

class ClearanceCreepageChecker:
    def __init__(self, board, marker_layer, config, report_lines, verbose=True, auditor=None):
        """
        Initialize checker with board context and configuration.
        
        Args:
            auditor: Reference to EMCAuditorPlugin instance (for utility functions)
        """
        self.board = board
        self.marker_layer = marker_layer
        self.config = config
        self.report_lines = report_lines  # Shared report log
        self.verbose = verbose
        self.auditor = auditor  # Access to plugin's utility functions
        
        # Utility functions (injected during check() call)
        self.draw_marker = None
        self.draw_arrow = None
        self.get_distance = None
    
    def log(self, msg, force=False):
        """Log to console and shared report_lines"""
        if self.verbose or force:
            print(msg)
            if self.verbose:
                self.report_lines.append(msg)
    
    def check(self, draw_marker_func, draw_arrow_func, get_distance_func):
        """Main entry point - receives injected utility functions"""
        # Store for reuse throughout module
        self.draw_marker = draw_marker_func
        self.draw_arrow = draw_arrow_func
        self.get_distance = get_distance_func
        
        # Use injected function from auditor
        nets_in_class = self.auditor.get_nets_by_class(self.board, "HIGH_VOLTAGE")
        
        # Perform checks...
        return violation_count
```

### Main Plugin Integration

```python
# File: emc_auditor_plugin.py
from clearance_creepage import ClearanceCreepageChecker

class EMCAuditorPlugin(pcbnew.ActionPlugin):
    
    # ===== REUSABLE UTILITY FUNCTIONS =====
    
    def get_distance(self, p1, p2):
        """Calculate 2D Euclidean distance between two points"""
        return math.sqrt((p1.x - p2.x)**2 + (p1.y - p2.y)**2)
    
    def get_nets_by_class(self, board, class_name):
        """
        Get all nets belonging to a Net Class (substring match).
        
        Handles:
        - Single class: "HighSpeed"
        - Multiple classes: "HighSpeed,Default" (comma-separated)
        - Wildcards: User patterns like "*In*" in Board Setup
        
        Returns:
            list: Net names (strings) in this class
        """
        matching_nets = []
        all_nets = board.GetNetInfo().NetsByName().values()
        
        for net in all_nets:
            net_class = net.GetNetClassName()
            net_name = net.GetNetname()
            
            # Substring match (handles comma-separated classes)
            if class_name in net_class and net_name:
                matching_nets.append(net_name)
        
        return matching_nets
    
    def draw_error_marker(self, board, pos, message, layer, marker_group):
        """Draw circle + text marker at violation location"""
        general = self.config.get('general', {})
        radius = pcbnew.FromMM(general.get('marker_circle_radius_mm', 0.8))
        # ... (implementation details)
    
    def draw_arrow(self, board, start_pos, end_pos, label, layer, marker_group):
        """Draw arrow from start to end with optional label"""
        # ... (implementation details)
    
    # ===== MODULE INTEGRATION =====
    
    def check_clearance_creepage(self, board, marker_layer, config):
        """Delegate to ClearanceCreepageChecker module"""
        
        # Create checker instance
        verbose = self.config.get('general', {}).get('verbose_logging', True)
        checker = ClearanceCreepageChecker(
            board=board,
            marker_layer=marker_layer,
            config=config,
            report_lines=self.report_lines,  # Shared report
            verbose=verbose,
            auditor=self  # Pass self for utility access
        )
        
        # Inject utility functions (dependency injection pattern)
        violations = checker.check(
            draw_marker_func=self.draw_error_marker,
            draw_arrow_func=self.draw_arrow,
            get_distance_func=self.get_distance
        )
        
        return violations
```

### Example 2: via_stitching.py Module

The via stitching module follows the same pattern, checking that critical signal vias have nearby ground return vias for EMI reduction.

```python
# File: via_stitching.py
from via_stitching import ViaStitchingChecker

class ViaStitchingChecker:
    def __init__(self, board, marker_layer, config, report_lines, verbose=True, auditor=None):
        """Initialize via stitching checker with board context"""
        self.board = board
        self.marker_layer = marker_layer
        self.config = config
        self.report_lines = report_lines
        self.verbose = verbose
        self.auditor = auditor  # Access to plugin utilities
        
        # Injected utility functions
        self.draw_marker = None
        self.draw_arrow = None
        self.get_distance = None
    
    def log(self, msg, force=False):
        """Log to console and shared report"""
        if self.verbose or force:
            print(msg)
            if self.verbose:
                self.report_lines.append(msg)
    
    def check(self, draw_marker_func, draw_arrow_func, get_distance_func):
        """Main entry point - receives injected utility functions"""
        # Store for reuse
        self.draw_marker = draw_marker_func
        self.draw_arrow = draw_arrow_func
        self.get_distance = get_distance_func
        
        # Get critical nets via Net Classes (preferred method)
        critical_classes = self.config.get('critical_net_classes', ['HighSpeed'])
        for crit_class in critical_classes:
            nets_in_class = self.auditor.get_nets_by_class(self.board, crit_class)
            # Check vias on these nets...
        
        return violation_count
```

**Main Plugin Integration:**
```python
# File: emc_auditor_plugin.py
from via_stitching import ViaStitchingChecker

def check_via_stitching(self, board, marker_layer, config):
    """Delegate to ViaStitchingChecker module"""
    
    if ViaStitchingChecker is None:
        print("âš ï¸  Via stitching checker module not available")
        return 0
    
    # Create checker instance
    verbose = self.config.get('general', {}).get('verbose_logging', True)
    checker = ViaStitchingChecker(
        board=board,
        marker_layer=marker_layer,
        config=config,
        report_lines=self.report_lines,
        verbose=verbose,
        auditor=self  # Pass self for utility access
    )
    
    # Inject utility functions
    violations = checker.check(
        draw_marker_func=self.draw_error_marker,
        draw_arrow_func=self.draw_arrow,
        get_distance_func=self.get_distance
    )
    
    return violations
```

**Configuration (emc_rules.toml):**
```toml
[via_stitching]
enabled = true
max_distance_mm = 2.0
critical_net_classes = ["HighSpeed", "Clock"]
ground_net_patterns = ["GND", "GROUND", "VSS"]
violation_message = "NO GND VIA"
draw_arrow_to_nearest_gnd = true
```

### Example 3: decoupling.py Module

The decoupling capacitor module checks that ICs have nearby decoupling capacitors on power pins for signal integrity.

```python
# File: decoupling.py
from decoupling import DecouplingChecker

class DecouplingChecker:
    def __init__(self, board, marker_layer, config, report_lines, verbose=True, auditor=None):
        """Initialize decoupling capacitor checker with board context"""
        self.board = board
        self.marker_layer = marker_layer
        self.config = config
        self.report_lines = report_lines
        self.verbose = verbose
        self.auditor = auditor  # Access to plugin utilities
        
        # Injected utility functions
        self.draw_marker = None
        self.draw_arrow = None
        self.get_distance = None
    
    def log(self, msg, force=False):
        """Log to console and shared report"""
        if self.verbose or force:
            print(msg)
            if self.verbose:
                self.report_lines.append(msg)
    
    def check(self, draw_marker_func, draw_arrow_func, get_distance_func):
        """Main entry point - receives injected utility functions"""
        # Store for reuse
        self.draw_marker = draw_marker_func
        self.draw_arrow = draw_arrow_func
        self.get_distance = get_distance_func
        
        # Get IC power pins and find nearest capacitors
        ic_prefixes = self.config.get('ic_reference_prefixes', ['U'])
        cap_prefixes = self.config.get('capacitor_reference_prefixes', ['C'])
        power_patterns = self.config.get('power_net_patterns', ['VCC', 'VDD'])
        
        # Scan for ICs and check power pin decoupling...
        return violation_count
```

**Main Plugin Integration:**
```python
# File: emc_auditor_plugin.py
from decoupling import DecouplingChecker

def check_decoupling(self, board, marker_layer, config):
    """Delegate to DecouplingChecker module"""
    
    if DecouplingChecker is None:
        print("âš ï¸  Decoupling checker module not available")
        return 0
    
    # Create checker instance
    verbose = self.config.get('general', {}).get('verbose_logging', True)
    checker = DecouplingChecker(
        board=board,
        marker_layer=marker_layer,
        config=config,
        report_lines=self.report_lines,
        verbose=verbose,
        auditor=self  # Pass self for utility access
    )
    
    # Inject utility functions
    violations = checker.check(
        draw_marker_func=self.draw_error_marker,
        draw_arrow_func=self.draw_arrow,
        get_distance_func=self.get_distance
    )
    
    return violations
```

**Configuration (emc_rules.toml):**
```toml
[decoupling]
enabled = true
max_distance_mm = 3.0
ic_reference_prefixes = ["U"]
capacitor_reference_prefixes = ["C"]
power_net_patterns = ["VCC", "VDD", "3V3", "5V"]
violation_message = "CAP TOO FAR ({distance:.1f}mm)"
draw_arrow_to_nearest_cap = true
show_capacitor_label = true
```

**Example 4: EMI Filtering Module** (`emi_filtering.py`)

Complex module (693 lines) for EMI filtering verification on interface connectors. Detects filter topologies (Pi, T, LC, RC), differential pair filters, and common-mode chokes.

**Module Interface:**
```python
class EMIFilteringChecker:
    def __init__(self, board, marker_layer, config, report_lines, verbose, auditor):
        """Initialize with dependency injection pattern."""
        self.board = board
        self.marker_layer = marker_layer
        self.config = config.get('emi_filtering', {})
        self.report_lines = report_lines
        self.verbose = verbose
        self.auditor = auditor
    
    def check(self, draw_marker_func, draw_arrow_func, get_distance_func):
        """Check EMI filtering on interface connectors.
        
        Returns: int - Number of violations found
        """
        # Scans connectors (default prefix 'J')
        # Detects interface types (USB, Ethernet, HDMI, CAN, RS485, RS232)
        # Checks each signal pad for EMI filtering
        # Detects differential pairs and common-mode filters
        # Classifies topology: Pi, T, LC, RC, L, C, R, simple
        # Creates violation markers for insufficient/missing filters
        ...
```

**Main Plugin Delegation:**
```python
def check_emi_filtering(self, board, marker_layer, config):
    """Check EMI filtering (delegates to module)."""
    if EMIFilteringChecker is None:
        print("âš ï¸  EMI filtering checker module not available")
        return 0
    
    verbose = self.config.get('general', {}).get('verbose_logging', True)
    checker = EMIFilteringChecker(
        board=board,
        marker_layer=marker_layer,
        config=config,
        report_lines=self.report_lines,
        verbose=verbose,
        auditor=self
    )
    
    return checker.check(
        draw_marker_func=self.draw_error_marker,
        draw_arrow_func=self.draw_arrow,
        get_distance_func=self.get_distance
    )
```

**Configuration ([emi_filtering] in emc_rules.toml):**
```toml
[emi_filtering]
enabled = true
connector_prefix = "J"
filter_component_prefixes = ["R", "L", "FB", "C", "D"]
max_filter_distance_mm = 10.0
min_filter_type = "LC"
violation_message = "NO EMI FILTER"

# Component class mappings for topology detection
component_classes.inductor_prefixes = ["L", "FB"]
component_classes.capacitor_prefixes = ["C"]
component_classes.resistor_prefixes = ["R"]

# Differential pair detection patterns
differential_pairs.patterns = [
    ["_P", "_N"], ["_p", "_n"], ["+", "-"],
    ["DP", "DM"], ["dp", "dm"],
    ["TXP", "TXN"], ["txp", "txn"],
    ["RXP", "RXN"], ["rxp", "rxn"],
    ["CANH", "CANL"]
]
differential_pairs.min_common_mode_choke_pins = 4

# Ground and power net patterns (for series/shunt analysis)
ground_patterns = ["GND", "GROUND", "VSS", "AGND", "DGND", "PGND"]
power_patterns = ["VCC", "VDD", "PWR", "+", "VBUS", "3V3", "5V"]
```

**Module Features:**
- **Interface Detection**: Identifies USB, Ethernet, HDMI, CAN, RS485, RS232 from reference/footprint names
- **Topology Classification**: Detects Pi (C-L-C), T (L-C-L), LC, RC, L, C, R, simple filters
- **Series/Shunt Analysis**: Determines if component is in-line (series) or to GND/power (shunt)
- **Differential Pair Detection**: Finds common-mode chokes (4+ pin inductors/FBs on both nets)
- **Common-Mode Capacitors**: Detects capacitors with pads on both differential nets
- **Filter Hierarchy**: Pi > T > LC > RC > L > C > R > simple
- **Differential Bonus**: "Differential + RC" treated as equivalent to single-ended "LC"
- **Per-Pad Markers**: Creates individual violation groups for each signal pad

### Benefits of This Architecture

âœ… **No Code Duplication** - Utility functions defined once in main plugin  
âœ… **Clean Separation** - Complex checks isolated in modules  
âœ… **Shared Logging** - All modules append to same `report_lines` list  
âœ… **Consistent Visualization** - All use same `draw_error_marker()` style  
âœ… **Testability** - Modules can be unit tested with mocked functions  
âœ… **Maintainability** - Update marker style in one place, affects all checks  

### When to Create a Module

**Create separate module if:**
- Check logic exceeds 200 lines
- Requires specialized data structures or algorithms
- Implements external standard (IEC, IPC, ISO)
- Reusable across multiple checks

**Keep in main plugin if:**
- Check logic < 100 lines
- Simple comparison/measurement
- No specialized domain knowledge

### Reusable Utility Functions in Main Plugin

**Geometry:**
```python
def get_distance(self, p1, p2)  # 2D Euclidean distance
```

**Visualization:**
```python
def draw_error_marker(self, board, pos, message, layer, group)  # Circle + text
def draw_arrow(self, board, start, end, label, layer, group)    # Directional arrow
```

**Board Utilities:**
```python
def get_nets_by_class(self, board, class_name)  # Net Class â†’ net names
```

**Always reuse these** - never reimplement in modules.

---

## ðŸ“ Logging Pattern for Modules

### Shared Report Lines

All modules share a common `report_lines` list passed from main plugin. This ensures a unified report at the end.

```python
# In module __init__:
class YourChecker:
    def __init__(self, board, marker_layer, config, report_lines, verbose=True, auditor=None):
        self.report_lines = report_lines  # Shared list from main plugin
        self.verbose = verbose
```

### Module Logging Method

**Every module should implement this pattern:**

```python
def log(self, msg, force=False):
    """
    Log message to console and report.
    
    Args:
        msg: Message string
        force: If True, always print (for errors/warnings)
               If False, only print if verbose=True
    """
    if self.verbose or force:
        print(msg)  # Always print to console
        if self.verbose:
            self.report_lines.append(msg)  # Only add to report if verbose
```

**Usage in module:**
```python
# Normal debug output (verbose mode only)
self.log("  Processing domain: HIGH_VOLTAGE (230V)")
self.log(f"  Found {len(features)} pads")

# Critical messages (always shown)
self.log("âš ï¸  No nets assigned to voltage domains", force=True)
self.log("âŒ VIOLATION: Clearance too small", force=True)
```

### Report Line Examples

**Format conventions:**
```python
# Section headers
self.log("\n=== CLEARANCE CHECK START ===", force=True)

# Subsection headers
self.log("\n--- Parsing Voltage Domains ---")

# Info messages (verbose only)
self.log("  Processing domain: MAINS (230V)")
self.log(f"    âœ“ Assigned {count} nets via Net Class")

# Warnings (always visible)
self.log("âš ï¸  No clearance table found, using defaults", force=True)

# Violations (always visible)
self.log(f"  âŒ VIOLATION: {domain_a} â†” {domain_b}", force=True)
self.log(f"     Actual: {actual:.2f}mm, Required: {required:.2f}mm", force=True)

# Summary (always visible)
self.log(f"\n=== CHECK COMPLETE: {violations} violation(s) ===", force=True)
```

### Unicode Symbols for Consistency

Use these standard symbols across all modules:
- âœ… Success / checkmark
- âŒ Error / failure
- âš ï¸  Warning / attention
- âœ“ Completed step
- â†’ Arrow / direction
- â†” Bidirectional

---

## ðŸ”§ Step-by-Step: Creating a New Module

### 1. Create Module File

**File**: `your_check.py` (same directory as emc_auditor_plugin.py)

```python
"""
Your Check Module for EMC Auditor Plugin
Implements [Standard/Feature Name] compliance checking

This module is called by emc_auditor_plugin.py and reuses its utility functions.
Configuration is read from emc_rules.toml [your_check] section.

Author: EMC Auditor Plugin
Version: 1.0.0
Last Updated: YYYY-MM-DD
"""

import pcbnew
import math


class YourChecker:
    """
    Handles [what this checker does].
    
    Standards supported:
    - [Standard Name]: [Brief description]
    """
    
    def __init__(self, board, marker_layer, config, report_lines, verbose=True, auditor=None):
        """
        Initialize checker with board context and configuration.
        
        Args:
            board: pcbnew.BOARD instance
            marker_layer: KiCad layer ID for drawing violation markers
            config: Dictionary from emc_rules.toml [your_check] section
            report_lines: List to append report messages (shared with main plugin)
            verbose: Enable detailed logging
            auditor: Reference to EMCAuditorPlugin instance
        """
        self.board = board
        self.marker_layer = marker_layer
        self.config = config
        self.report_lines = report_lines
        self.verbose = verbose
        self.auditor = auditor
        
        # Utility functions (injected during check() call)
        self.draw_marker = None
        self.draw_arrow = None
        self.get_distance = None
        
        # Results tracking
        self.violation_count = 0
    
    def log(self, msg, force=False):
        """Log message to console and report (only if verbose or force=True)"""
        if self.verbose or force:
            print(msg)
            if self.verbose:
                self.report_lines.append(msg)
    
    def check(self, draw_marker_func, draw_arrow_func, get_distance_func):
        """
        Main entry point - performs verification.
        
        Called from emc_auditor_plugin.py check_your_check() method.
        Utility functions are injected to avoid code duplication.
        
        Args:
            draw_marker_func: Function(board, pos, msg, layer, group)
            draw_arrow_func: Function(board, start, end, label, layer, group)
            get_distance_func: Function(pos1, pos2) returns distance
        
        Returns:
            int: Number of violations found
        """
        # Store utility functions
        self.draw_marker = draw_marker_func
        self.draw_arrow = draw_arrow_func
        self.get_distance = get_distance_func
        
        self.log("\n=== YOUR CHECK START ===", force=True)
        
        # Your implementation here...
        
        self.log(f"\n=== YOUR CHECK COMPLETE: {self.violation_count} violation(s) ===", force=True)
        return self.violation_count


# Module metadata
__version__ = "1.0.0"
__author__ = "EMC Auditor Plugin"
__description__ = "Brief description of what this module checks"
```

### 2. Import Module in Main Plugin

**File**: `emc_auditor_plugin.py` (top of file)

```python
# Import your module
try:
    from your_check import YourChecker
except ImportError as e:
    print(f"WARNING: Could not import your_check module: {e}")
    YourChecker = None
```

### 3. Add Integration Method in Main Plugin

```python
def check_your_feature(self, board, marker_layer, config):
    """Check [feature name] per [standard]
    
    This function delegates to the YourChecker module for implementation.
    Complete configuration is in emc_rules.toml [your_check] section.
    
    Returns:
        int: Number of violations found
    """
    # Check if module is available
    if YourChecker is None:
        self.log("âš ï¸  YourChecker module not available", force=True)
        self.log("HINT: Ensure your_check.py is in same directory as plugin", force=True)
        return 0
    
    # Create checker instance
    verbose = self.config.get('general', {}).get('verbose_logging', True)
    checker = YourChecker(
        board=board,
        marker_layer=marker_layer,
        config=config,
        report_lines=self.report_lines,
        verbose=verbose,
        auditor=self  # Pass self for utility functions
    )
    
    # Run check with injected utility functions
    violations = checker.check(
        draw_marker_func=self.draw_error_marker,
        draw_arrow_func=self.draw_arrow,
        get_distance_func=self.get_distance
    )
    
    return violations
```

### 4. Register in Run() Method

```python
def Run(self):
    # ... existing code ...
    
    # Your new check
    your_check_cfg = self.config.get('your_check', {})
    if your_check_cfg.get('enabled', False):
        violations_found += self.check_your_feature(board, marker_layer, your_check_cfg)
```

### 5. Add Configuration to emc_rules.toml

```toml
[your_check]
enabled = false  # Start disabled for testing
description = "Brief description of check"
violation_message = "VIOLATION: Your check failed"

# Your specific parameters
parameter1 = 10.0
parameter2 = ["value1", "value2"]
```

### Module Checklist

**Before committing:**
- [ ] Module file created with proper header docstring
- [ ] `__init__` receives all 6 parameters (board, marker_layer, config, report_lines, verbose, auditor)
- [ ] `log()` method implemented with `force` parameter
- [ ] `check()` method receives 3 injected functions
- [ ] Uses `self.auditor.get_nets_by_class()` if needed
- [ ] Import added to main plugin with try/except
- [ ] Integration method created in main plugin
- [ ] Registered in `Run()` method
- [ ] Configuration section added to emc_rules.toml
- [ ] Documentation updated (README.md)
- [ ] Module synced to KiCad plugins directory (run `sync_to_kicad.ps1`)

---

## ðŸ”Œ Using Main Plugin Utility Functions in Modules

### Accessing Utilities via `self.auditor`

Modules receive `auditor=self` reference in `__init__`. This provides access to all main plugin utility functions.

### Available Utility Functions

#### 1. `get_nets_by_class(board, class_name)` - Net Class Lookup

**Purpose**: Get all nets belonging to a KiCad Net Class

**Example in module:**
```python
# Get all nets in "HIGH_VOLTAGE" net class
high_voltage_nets = self.auditor.get_nets_by_class(self.board, "HIGH_VOLTAGE")
# Returns: ['MAINS_L', 'MAINS_N', 'DC_BUS+', 'DC_BUS-']

# Get all nets in "SIGNAL" net class
signal_nets = self.auditor.get_nets_by_class(self.board, "SIGNAL")
```

**How it works:**
- Uses **substring matching** in net class names
- Handles comma-separated classes: `"HighSpeed,Default"` matches both `"HighSpeed"` and `"Default"`
- Case-sensitive: `"HIGH_VOLTAGE"` != `"high_voltage"`
- Returns empty list if no matches

**Real example from clearance_creepage.py:**
```python
def _parse_voltage_domains(self):
    for domain_config in voltage_domains:
        domain_name = domain_config.get('name', 'Unknown')
        
        # Try Net Class first (preferred method)
        nets_in_class = self.auditor.get_nets_by_class(self.board, domain_name)
        
        if nets_in_class:
            for net_name in nets_in_class:
                domain_map[net_name] = {
                    'domain_name': domain_name,
                    'voltage_rms': voltage_rms,
                    'source': 'net_class'
                }
            self.log(f"  âœ“ Assigned {len(nets_in_class)} net(s) via Net Class")
        else:
            # Fallback to pattern matching
            self.log(f"  âš  No nets in Net Class '{domain_name}', trying patterns")
```

**Best Practice**: Always prefer Net Classes over pattern matching. They're:
- More reliable (user-controlled in KiCad)
- More explicit (visible in Board Setup)
- Easier to maintain (no regex/wildcards)

#### 2. `get_distance(point1, point2)` - Distance Calculation

**Purpose**: Calculate 2D Euclidean distance between two points

**Injected during `check()` call (do NOT access via `self.auditor`):**
```python
def check(self, draw_marker_func, draw_arrow_func, get_distance_func):
    self.get_distance = get_distance_func  # Store for later use
    
    # Use in your check logic:
    distance = self.get_distance(pad1_pos, pad2_pos)  # Returns internal units
    distance_mm = pcbnew.ToMM(distance)  # Convert to millimeters
```

**Example from clearance_creepage.py:**
```python
def _calculate_clearance(self, features_a, features_b):
    for feature_a in features_a:
        pos_a = feature_a[2]  # Position
        for feature_b in features_b:
            pos_b = feature_b[2]
            
            # Use injected distance function
            distance = self.get_distance(pos_a, pos_b)
            
            if distance < min_distance:
                min_distance = distance
    
    # Convert to mm for display
    distance_mm = pcbnew.ToMM(min_distance)
    return distance_mm
```

#### 3. `draw_error_marker(board, pos, message, layer, group)` - Violation Marker

**Purpose**: Draw circle + text at violation location

**Injected during `check()` call:**
```python
def check(self, draw_marker_func, draw_arrow_func, get_distance_func):
    self.draw_marker = draw_marker_func  # Store
    
    # Create violation group first
    violation_group = pcbnew.PCB_GROUP(self.board)
    violation_group.SetName(f"EMC_YourCheck_{item_id}_{self.violation_count}")
    self.board.Add(violation_group)
    
    # Draw marker
    self.draw_marker(
        self.board,
        violation_position,  # pcbnew.VECTOR2I
        "VIOLATION: Distance too small\n2.5mm < 3.0mm",  # Multi-line OK
        self.marker_layer,
        violation_group
    )
```

**Marker appearance:**
- Red circle (0.8mm radius, configurable)
- Text label offset 1.2mm above circle
- Text size 0.5mm (configurable)

#### 4. `draw_arrow(board, start, end, label, layer, group)` - Directional Arrow

**Purpose**: Draw arrow from violation to related component

**Injected during `check()` call:**
```python
def check(self, draw_marker_func, draw_arrow_func, get_distance_func):
    self.draw_arrow = draw_arrow_func  # Store
    
    # Draw arrow from violation to target
    self.draw_arrow(
        self.board,
        violation_pos,    # Start point
        target_pos,       # End point (component location)
        "â†’ C15",          # Optional label
        self.marker_layer,
        violation_group
    )
```

**Arrow appearance:**
- Line with 0.5mm arrowhead
- Optional text label at midpoint
- Same line width as marker circle

### Usage Pattern Summary

```python
class YourChecker:
    def __init__(self, ..., auditor=None):
        self.auditor = auditor  # Store reference
        self.draw_marker = None
        self.draw_arrow = None
        self.get_distance = None
    
    def check(self, draw_marker_func, draw_arrow_func, get_distance_func):
        # Store injected functions
        self.draw_marker = draw_marker_func
        self.draw_arrow = draw_arrow_func
        self.get_distance = get_distance_func
        
        # Use auditor for Net Class lookup
        nets = self.auditor.get_nets_by_class(self.board, "HighSpeed")
        
        # Use injected functions for geometry and visualization
        distance = self.get_distance(pos1, pos2)
        self.draw_marker(self.board, pos, "VIOLATION", layer, group)
        self.draw_arrow(self.board, start, end, "â†’ Target", layer, group)
```

**Why two access patterns?**
- `auditor.X()` - Functions that query board state (read-only)
- `self.X()` - Functions that modify board (draw markers, calculate geometry)

This separation makes testing easier (can mock drawing functions without full board).

---

### Current Implementation Status

**âœ… Implemented Rules:**
1. **Via Stitching** - Ensures GND return vias near high-speed signal vias
2. **Decoupling Capacitors** - Verifies caps near IC power pins (smart net matching)
3. **Ground Plane Continuity** - Checks continuous ground under/around high-speed traces

**ðŸš§ Configuration Ready (Implementation Pending):**
- Clearance/Creepage (IEC60664-1/IPC2221)
- Trace Width (current capacity)
- Differential Pairs (length matching)
- High-Speed Signals (stub length, bend radius)
- EMI Filtering (ferrite bead placement)

---

## CRITICAL RULE: Violation Marker Pattern

**ALL DRC checks MUST follow this exact pattern:**

### 1. Create Individual Violation Group
```python
violation_group = pcbnew.PCB_GROUP(board)
violation_group.SetName(f"EMC_{RuleCategory}_{ItemID}_{violations+1}")
board.Add(violation_group)
```

**Group Naming Examples:**
- `EMC_Decap_U1_VCC` - Decoupling check on IC U1, VCC net
- `EMC_Via_15` - Via stitching violation #15
- `EMC_GndPlane_CLK_3` - Ground plane check on CLK net, violation #3

**Why:** Allows users to select/delete individual violations via "Select Items in Group"

### 2. Draw Error Marker (Circle + Text)
```python
self.draw_error_marker(
    board,
    violation_position,     # pcbnew.VECTOR2I
    "VIOLATION MESSAGE",    # Can include {distance:.1f} placeholder
    marker_layer,
    violation_group
)
```

**Result:** Red circle (0.8mm radius) + text label at violation location

### 3. Draw Arrow to Related Component (OPTIONAL)
```python
if config.get('draw_arrow_to_target', True):
    self.draw_arrow(
        board,
        start_position,      # Where violation is
        target_position,     # Related component location
        "â†’ TARGET_REF",      # Arrow label (e.g., "â†’ C15")
        marker_layer,
        violation_group
    )
```

**Result:** Arrow with 0.5mm arrowhead pointing from violation to related item

---

## Configuration File Integration

**File**: `emc_rules.toml`  
**Format**: TOML (parsed with tomllib/tomli/toml)

**Minimum Required Parameters:**
```toml
[your_rule]
enabled = true                    # REQUIRED: Enable/disable check
description = "What it checks"    # REQUIRED: Documentation
violation_message = "TEXT HERE"   # REQUIRED: What to display

# Rule-specific logic parameters (customize as needed)
max_distance_mm = 2.0
net_classes = ["HighSpeed", "Clock"]
net_patterns = ["VCC", "GND"]

# Optional visual enhancements
draw_arrow_to_target = true
show_target_label = true
```

---

## Template for New DRC Rule

```python
def check_your_rule(self, board, marker_layer, config):
    """
    Template for new DRC rule implementation
    
    Args:
        board: pcbnew.BOARD object
        marker_layer: Layer ID for User.Comments
        config: dict from emc_rules.toml [your_rule] section
    
    Returns:
        int: Number of violations found
    """
    # Parse config parameters
    max_dist = pcbnew.FromMM(config.get('max_distance_mm', 2.0))
    net_classes = config.get('critical_net_classes', ['HighSpeed'])
    violation_msg = config.get('violation_message', 'VIOLATION FOUND')
    draw_arrow = config.get('draw_arrow_to_target', True)
    
    violations = 0
    
    # Get items to check
    items_to_check = self.get_items_for_check(board, net_classes)
    
    if not items_to_check:
        print(f"WARNING: No items found for [your_rule]. Skipping.")
        return 0
    
    # Check each item
    for item in items_to_check:
        if self.detect_violation(item):
            # Step 1: Create group
            violation_group = pcbnew.PCB_GROUP(board)
            violation_group.SetName(f"EMC_YourRule_{item.GetNetname()}_{violations+1}")
            board.Add(violation_group)
            
            # Step 2: Draw circle + text
            violation_pos = item.GetPosition()
            self.draw_error_marker(
                board, 
                violation_pos, 
                violation_msg, 
                marker_layer, 
                violation_group
            )
            
            # Step 3 (optional): Draw arrow
            if draw_arrow:
                target_pos = self.find_related_component(item)
                if target_pos:
                    self.draw_arrow(
                        board,
                        violation_pos,
                        target_pos,
                        f"â†’ {item.GetReference()}",
                        marker_layer,
                        violation_group
                    )
            
            violations += 1
    
    return violations
```

---

## Existing Helper Functions (DO NOT REIMPLEMENT)

```python
# Distance calculation (2D Euclidean)
distance = self.get_distance(point1, point2)  # Returns internal units

# Draw violation markers
self.draw_error_marker(board, pos, message, layer, group)
self.draw_arrow(board, start_pos, end_pos, label, layer, group)

# Clear old markers before run
self.clear_previous_markers(board)

# Unit conversions
internal_units = pcbnew.FromMM(mm_value)
mm_value = pcbnew.ToMM(internal_units)
```

---

## Registration in Run() Method

**ALWAYS register your check in the Run() method:**

```python
def Run(self):
    board = pcbnew.GetBoard()
    self.clear_previous_markers(board)
    
    general = self.config.get('general', {})
    marker_layer = board.GetLayerID(general.get('marker_layer', 'Cmts.User'))
    
    violations_found = 0
    
    # Existing checks...
    via_cfg = self.config.get('via_stitching', {})
    if via_cfg.get('enabled', True):
        violations_found += self.check_via_stitching(board, marker_layer, via_cfg)
    
    # YOUR NEW CHECK HERE:
    your_rule_cfg = self.config.get('your_rule', {})
    if your_rule_cfg.get('enabled', False):  # Default: disabled for new rules
        violations_found += self.check_your_rule(board, marker_layer, your_rule_cfg)
    
    pcbnew.Refresh()
    print(f"EMC Audit Complete. Found {violations_found} violation(s).")
```

---

## Visual Consistency Requirements

**All markers MUST use these dimensions:**
- Circle radius: `0.8mm` (from config `marker_circle_radius_mm`)
- Line width: `0.1mm` (from config `marker_line_width_mm`)
- Text size: `0.5mm` (from config `marker_text_size_mm`)
- Text offset: `1.2mm` (from config `marker_text_offset_mm`)
- Arrow head: `0.5mm` length (hardcoded in `draw_arrow()`)

**Layer**: Always `User.Comments` (Cmts.User)

**Colors**: KiCad manages layer colors - plugin draws shapes only

---

## Error Handling Pattern

```python
try:
    # Your checking logic
    if not required_data:
        print(f"WARNING: Missing data for [your_rule]. Skipping check.")
        return 0
    
    # Perform checks...
    
except Exception as e:
    print(f"ERROR in [your_rule] check: {e}")
    import traceback
    traceback.print_exc()
    return 0
```

---

## Testing Checklist

Before committing new DRC rule:

- [ ] Rule has `enabled = true/false` toggle in config
- [ ] Violation markers visible on User.Comments layer
- [ ] Each violation has unique group name starting with "EMC_"
- [ ] Right-click marker â†’ "Select Items in Group" selects all markers
- [ ] Re-running plugin clears old markers
- [ ] Console prints "Found X violation(s)"
- [ ] README.md updated with usage example and visualization
- [ ] Config file includes properly documented template

---

## Common Pitfalls to Avoid

âŒ **WRONG:** Creating one group for all violations
```python
# Don't do this:
violation_group = pcbnew.PCB_GROUP(board)
board.Add(violation_group)
for item in items:
    self.draw_error_marker(...)  # All in same group
```

âœ… **CORRECT:** Create individual group per violation
```python
# Do this:
for item in items:
    violation_group = pcbnew.PCB_GROUP(board)  # New group per violation
    board.Add(violation_group)
    self.draw_error_marker(...)
```

âŒ **WRONG:** Hardcoding marker dimensions
```python
radius = 800000  # Don't hardcode internal units
```

âœ… **CORRECT:** Use config values
```python
radius = pcbnew.FromMM(self.config['general']['marker_circle_radius_mm'])
```

âŒ **WRONG:** Missing group name prefix
```python
violation_group.SetName(f"Violation_{n}")  # Won't be cleaned up properly
```

âœ… **CORRECT:** Use "EMC_" prefix
```python
violation_group.SetName(f"EMC_YourRule_{n}")  # Cleaned by clear_previous_markers()
```

---

## Performance Guidelines

- **Avoid O(nÂ³)** - Keep checks O(nÂ²) or better
- **Cache layer lookups** - Call `board.GetLayerID()` once
- **Spatial indexing** - Group items by layer before distance checks
- **Conditional arrows** - Only draw if `draw_arrow = true` in config
- **Early returns** - Exit if no items to check

---

## Files to Modify When Adding New Rule

1. **emc_auditor_plugin.py**
   - Add `check_your_rule()` method
   - Register in `Run()` method
   - Update `get_default_config()` if needed

2. **emc_rules.toml**
   - Add `[your_rule]` section with parameters
   - Document all config options with comments

3. **README.md**
   - Add usage example to "Usage" section
   - Update "Implemented Rules" or "Planned Rules" table
   - Add visualization example if pattern differs

4. **YOUR_RULE.md** (optional)
   - Create detailed documentation if rule is complex
   - Include implementation rationale and EMC theory

---

## Priority Order for Future Implementation

Based on `emc_rules.toml` configuration:

1. **Trace Width** - Power trace current capacity (IPC-2221)
2. **Clearance/Creepage** - High-voltage safety (IEC60664-1)
3. **Differential Pairs** - Length matching, impedance control
4. **High-Speed Signals** - Stub length, bend radius, via count
5. **EMI Filtering** - Ferrite bead/filter placement on interfaces

All use the **same marker visualization pattern**.

---

## Questions or Issues?

- **Plugin Architecture**: See `EMCAuditorPlugin` class in `emc_auditor_plugin.py`
- **Marker Drawing**: See `draw_error_marker()` and `draw_arrow()` methods
- **Config Parsing**: See `load_config()` and `get_default_config()` methods
- **Examples**: Study `check_via_stitching()`, `check_decoupling()`, `check_ground_plane()`

**License**: MIT License  
**KiCad Version**: 9.0.7+  
**Python Version**: 3.8+ (requires tomli/toml for Python < 3.11)
